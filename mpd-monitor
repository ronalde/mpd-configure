#!/usr/bin/env bash

## This script for linux with bash 4.x displays the properties of a
## digital audio file as stored, transferred by mpd and decoded by alsa.
##
##  Copyright (C) 2015 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## Source:    https://github.com/ronalde/mpd-configure
## See also:  http://lacocina.nl/detect-alsa-output-capabilities


LANG=C

## TODO: handle non-local mpd
MPD_HOST="${MPD_HOST:-localhost}"
MPD_PORT="${MPD_PORT:-6600}"

MPD_SOCKET="/dev/tcp/${MPD_HOST}/${MPD_PORT}"

MPD_PHONY_URL="mpd://${MPD_HOST}:${MPD_PORT}"

#DEBUG=True
REMOTEURL="https://raw.githubusercontent.com/ronalde/mpd-configure/mpd-monitor"
CMD_ALSACAPS="alsa-capabilities"
ALSACAPS_OUTPUT=""

file_samplerate=""
file_sampleencoding=""

alsa_samplerate=""
alsa_sampleencoding=""

### generic functions

function echo_stderr() {
    printf "$@\n" 1>&2; 
}

function die() {
    echo_stderr "\nError: $@"
    exit 1
}

function inform() {
    echo_stderr "(NOTICE: $@)\n"
}

function debug() {
    echo_stderr "DEBUG *** $@"
}

function command_not_found() {
    ## give installation instructions for package $2 when command $1
    ## is not available, optional with non default instructions $3
    ## and exit with error

    command="$1"
    package="$2"
    instructions="${3:-}"
    msg="command \`${command}' not found. "
    if [[ -z "${instructions}" ]]; then
	msg+="Users of Debian and Ubuntu can install it with:\n"
	msg+=" sudo apt-get install ${package}\n"
	msg+="while Arch users can use:\n"
	msg+=" sudo pacman -S ${package}"
    else
	msg+="${instructions}"
    fi
    die "${msg}"

}


function check_commands() {
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    CMD_SOXI="$(which soxi || command_not_found "soxi" "sox")"

    if [[ -z  "${CMD_SOXI}" ]]; then
	die "One or more needed commands are missing."
    fi
}


function is_mpd_local() {
    ## determine if mpd is running local, otherwise exit gracefully.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    loopback_regexp="^127."
    local_ipaddress=""

    if [[ -z "${MPD_HOST}" ]]; then
	return 0
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "MPD_HOST is set to \`${MPD_HOST}'" 

	## environment variable is set
	if [[ "${MPD_HOST}" =~ ${loopback_regexp} ]] || [[  "${MPD_HOST}" = "localhost" ]] ; then
	    ## points to a loopback address
	    return 0
	else
 	    local_ipaddress="$(hostname --ip-addresses)"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "local ip address \`${local_ipaddress}'" 
	    
	    if [[ "${MPD_HOST}" = $(printf "%s" ${local_ipaddress}) ]]; then
		[[ ! -z "${DEBUG}" ]] && \
		    debug "mpd is running local" 

		return 0
	    else
		## assume it is not local
		return 1
	    fi
	fi
    fi
   
}

function get_mpdconf_filepath() {
    ## check availability if each possible mpd configuration file in
    ## order.  Return full path to the file or empty string on error.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 
    
    for file in $XDG_CONFIG_HOME/mpd/mpd.conf \
		    ~/.mpdconf \
		    ~/.mpd/mpd.conf \
		    /etc/mpd.conf; do
	if [[ -f "${file}" ]]; then
	    [[ ! -z "${DEBUG}" ]] && \
		debug "will use mpd conf file: \`${file}'."
	    printf "%s" "${file}"
	    break
	fi
    done
}


function get_mpdconf_parameter() {
    ## look up a parameter in the mpd configuration file and return
    ## its value, return an error when not found.
   
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    parameter="$1"
    value="$(grep "${parameter}" "${MPD_CONFIGURATIONFILE}" | \
awk '{ print $2}' | \
sed 's/\"//g')"

    if [[ $? -ne 0 ]]; then 
	die "could not extract \`${parameter}' \
from mpd configuration file "${MPD_CONFIGURATIONFILE}""
    else
	## return it 
	printf "%s" "${value}"
    fi
}


function get_mpd_musicdir() {
    ## extract music_directory from mpd configuration file, and return
    ## it if it's accessible.
    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$*'" 

    msg=""
    mpdconf_parameter="music_directory"
    mpd_musicdir="$(get_mpdconf_parameter "${mpdconf_parameter}")"

    if [[ $? -eq 0 ]]; then 
	msg="trying ${mpdconf_parameter}: \`${mpd_musicdir}' ... "
	if [[ ! -d "${mpd_musicdir}" ]]; then
	    msg+="not accessible."
	    die "${msg}"
	else
	    msg+="done."
	    [[ ! -z "${DEBUG}" ]] && debug "${msg}"	    
	    ## return it 
	    printf "%s" "${mpd_musicdir}"
	fi
    fi
}

function get_mpd_device() {
    ## extract device from mpd configuration file, and return
    ## it.
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    ## count the number of audio_outputs in mpd configuration
    mpdconf_parameter="audio_output"
    mapfile -t mpd_audio_output < <(get_mpdconf_parameter "${mpdconf_parameter}")
    if [[ ${#mpd_audio_output[@]} -gt 1 ]]; then
	inform "multiple mpd audio outputs found, will use first device only."
    fi
	

    msg=""
    mpdconf_parameter="device"
    mpd_device="$(get_mpdconf_parameter "${mpdconf_parameter}")"
    
    if [[ $? -ne 0 ]]; then
	die "Could not get alsa device from the mpd configuration file."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "will use mpd device \`${mpd_device}'"
	printf "%s" "${mpd_device}"
    fi
}


function get_file_samplerate() {
    ## get the sample rate of the file currently played by mpd using soxi
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}'"  

    soxi_output="$1"

    # `Sample Rate    : 44100'
    sr_regexp="Sample Rate[[:space:]]*:[[:space:]]([0-9]*)" 
    
    while read -r line; do 
	if [[ "${line}" =~ ${sr_regexp} ]]; then
	    file_samplerate="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "file_samplerate: \`${file_samplerate}'."
	    printf "%s" "${file_samplerate}"
	fi
    done<<<"${soxi_output}"
}


function get_file_sampleencoding() {
    ## get the sample encoding of the file currently played by mpd using soxi
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}'"  

    soxi_output="$1"

    # `Sample Encoding: 16-bit FLAC'
    # or use `Precision      : 16-bit'
    se_regexp="Sample Encoding[[:space:]]*:[[:space:]]([0-9]*)-bit.*" 
    
    while read -r line; do 
	if [[ "${line}" =~ ${se_regexp} ]]; then 
	    file_sampleencoding="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "file_sampleencoding: \`${file_sampleencoding}'."
	    printf "%s" "${file_sampleencoding}"
	    
	fi
    done<<<"${soxi_output}"
}


function get_alsa_samplerate() {
    ## get the properties of the file currently played by mpd using alsa
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    alsa_streamfile="$1"

    ## USB streamfile
    # Sample rate: Momentary freq = 95999 Hz (0xb.fff8)
    sr_regexp="Momentary freq[[:space:]]=[[:space:]]([0-9]*)[[:space:]]Hz[[:space:]].*"
    ## Any hwparamsfile
    ## rate: 96000 (96000/1)
    sr_regexp="^rate:[[:space:]]([0-9]*)[[:space:]]\(.*\)"
    
    while read -r line; do 
	if [[ "${line}" =~ ${sr_regexp} ]]; then
	    alsa_samplerate="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "alsa_samplerate: \`${alsa_samplerate}'."
	    printf "%s" "${alsa_samplerate}"
	fi
    done<"${alsa_streamfile}"
}


function get_alsa_sampleencoding() {
    ## get the properties of the file currently played by mpd using alsa
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    alsa_streamfile="$1"

    ## USB streamfile
    ## Encoding format: Format: S32_LE
    se_regexp="Format:[[:space:]]([A-Z_0-9]*)" 

    ## Any hwparams file
    ## format: S32_LE
    se_regexp="^format:[[:space:]](.*)"
    
    while read -r line; do 
	if [[ "${line}" =~ ${se_regexp} ]]; then 
	    alsa_sampleencoding="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "alsa_sampleencoding: \`${alsa_sampleencoding}'."
	    printf "%s" "${alsa_sampleencoding}"
	fi
    done<"${alsa_streamfile}"  
}


function get_alsa_streamfile() {
    ## use alsa-capabilities to get the stream file for the (hardware
    ## address of the) alsa interface specified in the mpd
    ## configuration file (needed for `get_alsa_props').
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    #monitor file           =  /proc/asound/card1/stream0
    alsa_streamfile=""
    alsa_streamfile_regexp="monitor[[:space:]]file[[:space:]]*=[[:space:]]*(.*)"
    alsa_hwaddress="$(get_mpd_device)"
    alsa_hwaddress="${alsa_hwaddress/hw:/}"
    alsa_dev_nr="${alsa_hwaddress%%,*}"
    [[ ! -z "${DEBUG}" ]] && \
	debug "using alsa_dev_nr: \`${alsa_dev_nr}'"

    alsa_if_nr="${alsa_hwaddress##*,}"
    [[ ! -z "${DEBUG}" ]] && \
	debug "using alsa_if_nr: \`${alsa_if_nr}'"

    alsa_if_hwparamsfile="/proc/asound/card${alsa_dev_nr}/pcm${alsa_if_nr}p/sub0/hw_params"
    [[ ! -z "${DEBUG}" ]] && \
	debug "alsa_if_hwparamsfile: \`${alsa_if_hwparamsfile}'" 
    
    if [[ ! -f "${alsa_if_hwparamsfile}" ]]; then
	die "alsa_if_hwparamsfile \`${alsa_if_hwparamsfile}' is not accessible."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "alsa_if_hwparamsfile: \`${alsa_if_hwparamsfile}'."
	## return it to the calling function
	printf "%s" "${alsa_if_hwparamsfile}"
    fi
}

function remote_mpd_command() {
    ## execute a command using the mpd protocol on a pseudo device
    ## file pointing at a mpd host
    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    mpd_command="$@"

    ## make file descriptor 5 a read an write copy of the pseudo device file
    ## see: http://www.tldp.org/LDP/abs/html/devref1.html
    exec 5<> ${MPD_SOCKET} 2>/dev/null

    ## quit when connection failed
    if [[ $? -ne 0 ]]; then
	die "Could not connect to ${MPD_PHONY_URL}."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "connected to ${MPD_PHONY_URL}."
    fi

    ## feed the mpd password to the connection when specified on the
    ## commandline or set as an environment variable
    if [[ ! -z "${MPD_PASS}" ]]; then
	echo "password ${MPD_PASS}" >&5;
    fi
    
    ## send specified mpd_command to mpd's descriptor
    echo "${mpd_command}" >&5
    ## close the connection
    echo "close" >&5
    
    ## read from mpd's descriptor
    mpd_out=$(cat <&5)
    ## return the output to the calling function
    printf "%s" "${mpd_out}"
  
}

function get_mpd_currentsong() {

    [[ ! -z "${DEBUG}" ]] && \
	debug "entering \`${FUNCNAME}' with arguments \`$*'"

    mpd_currentsong_output="$(remote_mpd_command currentsong)"
    ## file: some/relative/path/song.wav
    mpd_currentsong_regexp="^file:[[:space:]](.*)$"
    while read -r line; do
	if [[ "${line}" =~ ${mpd_currentsong_regexp} ]]; then
	    mpd_currentsong="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_currentsong: \`${mpd_currentsong}'."
	    ## return the relative file name
	    printf "%s" "${mpd_currentsong}"
	    break
	fi
    done <<<"${mpd_currentsong_output}"

}

function get_mpd_samplerate() {

    mpd_status="$@"
    
    #audio: 96000:24:2
    mpd_status_audio_regexp="^audio:[[:space:]]([0-9]*):([0-9]*):([0-9]*)$"
    
    while read -r line; do
	
	if  [[ "${line}" =~ ${mpd_status_audio_regexp} ]]; then
	    ## get properties of audio file currently playing
	    msg="$(printf "%s:%s:%s" ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]})"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_audio: \`${msg}'"

	    mpd_samplerate="${BASH_REMATCH[1]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_samplerate: \`${mpd_samplerate}'"
	    printf "%s" "${mpd_samplerate}"
	    
	fi
    done <<<"${mpd_status}"
}

function get_mpd_bitdepth() {

    msg=""
    mpd_status="$@"
    
    #audio: 96000:24:2
    mpd_status_audio_regexp="^audio:[[:space:]]([0-9]*):([0-9]*):([0-9]*)$"
    
    while read -r line; do
	
	if  [[ "${line}" =~ ${mpd_status_audio_regexp} ]]; then
	    ## get properties of audio file currently playing
	    msg="$(printf "%s:%s:%s" ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]})"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_audio: \`${msg}'"
	    
	    mpd_bitdepth="${BASH_REMATCH[2]}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug "mpd_bitdepth: \`${mpd_bitdepth}'"
	    ## return the result
	    printf "%s" "${mpd_bitdepth}"
	    
	fi
    done <<<"${mpd_status}"
}

function is_mpd_playing() {

    mpd_status="$@"
    
    ## state: stop|play
    mpd_status_state_regexp="state:[[:space:]]([a-z]*)"

    while read -r line; do
	
	if [[ "${line}" =~ ${mpd_status_state_regexp} ]]; then
	    mpd_state="${BASH_REMATCH[1]}"
	    
	    if [[ "${mpd_state}" =~ "stop" ]]; then
		[[ ! -z "${DEBUG}" ]] && \
		    debug "mpd_state: \`${mpd_state}'"
		## exit when state is stopped
		return 1
		break
	    else
		[[ ! -z "${DEBUG}" ]] && \
		    debug "mpd on ${MPD_PHONY_URL} is running and playing a file."
		
	    fi
	fi
    done <<<"${mpd_status}"

}

function get_soxi_props() {

    stored_file_path="$@"
    
    if [[ ! -f "${stored_file_path}" ]]; then
	[[ ! -z "${DEBUG}" ]] && \
	    debug "specified path \`${stored_file_path}' \
is not a file or is not accessible."
	die "specified path \`${stored_file_path}' \
is not a file or is not accessible. Can't continue."
    else
	[[ ! -z "${DEBUG}" ]] && \
	    debug "checking file: \`${stored_file_path}'."
    fi

}


mpd_state=""
mpd_samplerate=""
mpd_bitdepth=""
mpd_channels=""

msg_remote_intro="Currently the script only functions when mpd runs locally."
msg_remote_next="It may be run on a remote host running mpd using ssh, eg"
msg_remote_ssh="ssh \$username@\$remotehost 'bash <(wget -q -O - "https://raw.githubusercontent.com/ronalde/mpd-configure/master/mpd-monitor")'"


msg_remote="$(printf "%s\n%s\n%s\n" \
"${msg_remote_intro}" "${msg_remote_next}" "${msg_remote_ssh}")"
is_mpd_local || die "${msg_remote}"
## return the results of mpd's `status' command 
mpd_status="$(remote_mpd_command status)"

ret="$(is_mpd_playing "${mpd_status}")"

## exit when mpd is not playing a file
[[ $? -ne 0 ]] && \
    die "mpd on ${MPD_PHONY_URL} is not playing a file."

mpd_currentsong="$(get_mpd_currentsong)"

## check if soxi command is available; exit with error when
## it is not
check_commands || exit 1

## get the path of the mpd configuration file
MPD_CONFIGURATIONFILE="${MPD_CONFIGURATIONFILE:-}"

if [[ -z "${MPD_CONFIGURATIONFILE}" ]]; then
    MPD_CONFIGURATIONFILE="$(get_mpdconf_filepath)"
fi


## get the path of the hwparams file for the alsa interface from the
## mpd configuration file
alsa_streamfile="$(get_alsa_streamfile)"

## get the path to the (parent) music directory from the mpd
## configuration file
mpd_musicdir="$(get_mpd_musicdir)"

msg_samplerate="sample rate"
msg_sampleencoding="sample encoding"
msg_source="file on storage"       ## file on storage             < soxi
msg_transfer="transf by mpd"    ## file as transferred         < mpd
msg_playback="playback by alsa"    ## file as converted to analog < alsa

## get the path of the current playing song, relative to
## `mpd_musicdir'
stored_file_path="${mpd_musicdir}/${mpd_currentsong}"

## use soxi to determine properties of stored file
soxi_output="$(${CMD_SOXI} "${stored_file_path}")"
source_samplerate="$(get_file_samplerate "${soxi_output}")"
source_sampleencoding="$(get_file_sampleencoding "${soxi_output}")"

## use mpd to determine properties of transferred file
transfer_samplerate="$(get_mpd_samplerate "${mpd_status}")"
transfer_sampleencoding="$(get_mpd_bitdepth "${mpd_status}")"

playback_samplerate="$(get_alsa_samplerate "${alsa_streamfile}")"
playback_sampleencoding="$(get_alsa_sampleencoding "${alsa_streamfile}")"

printf "Properties of\n\`%s':\n" "${stored_file_path}"

printf " %.0s" {1..22}
printf "%-13s %-13s\n" "${msg_samplerate}" "${msg_sampleencoding}"
printf " %.0s" {1..22}
printf "=%.0s" {1..13}
printf " "
printf "=%.0s" {1..13}
printf "\n"

printf " %-20s %-13s %-13s\n" \
       "${msg_source}" "${source_samplerate}" "${source_sampleencoding}"

printf " %-20s %-13s %-13s\n" \
       "${msg_transfer}" "${transfer_samplerate}" "${transfer_sampleencoding}"

printf " %-20s %-13s %-13s\n\n" \
       "${msg_playback}" "${playback_samplerate}" "${playback_sampleencoding}"

