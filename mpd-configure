#!/usr/bin/env bash
##
## `mpd-configure' is a bash script that tries to ease the
## configuration of mpd for audiophile purposes.
##
##  Copyright (C) 2014 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://github.com/ronalde/mpd-configure
## 
## Also see `README'

LANG=C

function echo_stderr() {
    ## prevent messages from mixing with the actual output of the
    ## script (ie stdout)

    echo -e "$@" 1>&2; 
}

function die() {
    ## exit with error while displaying an error message $1

    echo_stderr "ERROR: $@"
    exit 1
}

function debug() {
    echo_stderr "DEBUG: ${1}"    
}


function write_error() {
    ## the conf file or dir ($1) is not writable and exists if ($2) is set. 
    ## echo the contents of the generated conf file to std_out and
    ## exit with error

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    path_notwritable="${1}"
    path_exists="${2}"

    if [[ -z ${path_exists} ]]; then
	msg="\n${MSG_TAB}can't write to ${path_notwritable}"
    else
	msg="\n${MSG_TAB}although ${path_notwritable} exists, it is not writable."
    fi
    msg="${msg}\n${MSG_MARGIN}the ${MSG_MPD_CONFFILE} can't be saved."
    [[ ! -z ${DEBUG} ]] && \
	debug "${msg}\n${MSG_TAB}Will display the generated contents instead."

    inform "${CONF_CONTENTS}"
    die "${msg}"
}


function really_write() {
    ## writes the contents of CONF_CONTENTS to MPD_CONFFILE

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    if [[ -z "${DRYRUN}" ]]; then
	## do the actual writing
	echo -e "${CONF_CONTENTS}" > "${MPD_CONFFILE}" && \
	    msg="${MSG_DONE}" || die "Could not write to \`${MPD_CONFFILE}': $?"
    else
	## dryrun enabled: display the contents of mpd_conffile
	msg="DRYRUN: Not writing to ${MPD_CONFFILE}: \
\n${CONF_CONTENTS} \
\n${MSG_DONE_DRYRUN}"
    fi

    ## display the result
    printf "${msg}"

    [[ ! -z "${DEBUG}" ]] && debug "result: \`${msg}'"

}

function write_conffile() {
    ## prepares to write to the mpd configuration file.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    msg=""

    mpd_conf_dir="$(dirname ${MPD_CONFFILE})"

    if [[ ! -d "${mpd_conf_dir}" ]]; then
	[[ ! -z "${DEBUG}" ]] && debug "conf dir does not exist, try to create it"
	dirok="$(mkdir -p "${mpd_conf_dir}" 2>&1 >/dev/null)"
	[[ ! -z ${dirok} ]] && \
	    msg="Can't create directory \`${mpd_conf_dir}' which is necessary for storing \
\n${MSG_MARGIN}${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
    else
	## conf dir exists, check if it writable
	[[ -w "${mpd_conf_dir}" ]] || \
	    msg="No write permission in directory \`${mpd_conf_dir}'."
    fi

    ## exit with error if this failed
    [[ ! -z "${msg}" ]] && die "\n${MSG_TAB}${msg}"

    [[ ! -z "${DEBUG}" ]] && debug "mpd_conf_dir ok: \`${mpd_conf_dir}'"

    if [[ -f "${MPD_CONFFILE}" ]]; then

	## conf file exists, check if its writable
	if [[ ! -w "${MPD_CONFFILE}" ]]; then
	    ## not writable, exit with error 
	    msg="\n${MSG_TAB}Existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' is present, \
but is not writable."
	    die "${msg}"
	fi

	## is writable, prompt to overwrite
	msg="${MSG_TAB}Original ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' exists."
	inform "${msg}"
	## only prompt when OVERWRITE_EXISTING_CONFFILE is not set
	[[ ! -z "${DEBUG}" ]] && \
	    debug "OVERWRITE_EXISTING_CONFFILE: \`${OVERWRITE_EXISTING_CONFFILE}'"
	if [[ -z ${OVERWRITE_EXISTING_CONFFILE} ]]; then
	    prompt="${MSG_MARGIN}>> Overwrite it?: "
	    overwrite="$(read -e -p "${prompt}" -i "Yes" overwrite && \
echo -e "${overwrite}")"
	    ## if prompt returns (downcased) `yes' then overwrite the file
	    if ! [[ "${overwrite,,}" = "yes" ]]; then
		## user choose no to overwrite; exit with message
		inform "Not overwriting existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
		exit 0
	    fi
	fi
    fi

    ## do the actual writing
    fileok="$(really_write)"

}


function command_not_found() {
    ## give installation instructions when a command is not available
    ## and exit with error

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    command="$1"
    package="$2"
    instructions="$3"
    msg="Error: command \`${command}' not found. "

    [[ -z "${instructions}" ]] && \
	msg+="Users of Debian (or deratives, like Ubuntu) can install it with: \
\n sudo apt-get install ${package}" || \
	msg+="${instructions}"

    die "${msg}"

}

function fetch_alsa_hwaddresses() {
    ## use alsa-capabilities script to get alsa output interfaces; if
    ## one interface is found, use that, otherwise display all of them
    ## and ask the user which to use.
    ##
    ## stores the hardware address and label in global variables
    ## ALSA_AIF_HWADDRESS and ALSA_AIF_DEVLABEL.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    ## prompt when multiple alsa interfaces are found
    msg_multiple_alsahw="${MSG_TAB}Multiple interfaces found."

    ## when more than one matching output device is found and
    ## USER_PROMPTS is not set, prompt the user to select one,
    ## defaults to the first device found.

    ## put the result of alsa-capabilities in an array
    return_alsa_interface

    [[ ! -z ${DEBUG} ]] && \
	debug "number of returned alsa interfaces: ${#ALSA_AIF_HWADDRESSES[@]}"

    ## set first interface found as default
    selectedkey=0
    default_aif_hwaddress="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"

    if [[ ${#ALSA_AIF_HWADDRESSES[@]} -gt 1 ]]; then
	if [[ -z "${USER_PROMPTS}" ]]; then
	    ## display instructions for multiple interfaces and prompt
	    #echo_stderr "${msg_multiple_alsahw}"
	    #prompt="${MSG_MARGIN}>> Interface to use: "
	    msg_prompt=">> Specify the interface to use and press [ENTER] to confirm: "
	    prompt="$(printf '%s\n%s' "${msg_multiple_alsahw}" \
"${MSG_MARGIN}${msg_prompt}")"
	    ## prompt the user to select a interface
	    alsa_aif_hwaddress="$(read -e -p "${prompt}" \
-i "${default_aif_hwaddress}" alsa_aif_hwaddress && \
echo -e "${alsa_aif_hwaddress}")"

	    for key in "${!ALSA_AIF_HWADDRESSES[@]}"; do
		## set the user selected key and exit loop
		if [[ "${ALSA_AIF_HWADDRESSES[$key]}" = "${alsa_aif_hwaddress}" ]]; then
		   let selectedkey=${key}
		   break
		fi
	    done
	fi
    fi

    ## store the hardware address and label for usage in audio_conf
    CONF_ALSA_AIF_HWADDRESS="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"
    CONF_ALSA_AIF_DEVLABEL="${ALSA_AIF_DEVLABELS[${selectedkey}]} - \
${ALSA_AIF_LABELS[${selectedkey}]}"
}


function check_readable_path() {
    ## checks if path ($1), needed for ($2) is readable, or adds
    ## problem description ($2) to problems array

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"
    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't access or read ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"
    [[ -d "${path}" || -f "${path}" ]] || PROBLEMS+=("${msg}") 
}


function check_writeable_path() {
    ## checks if path ($1), needed for ($2) is writeable, or adds
    ## problem description ($2) to problems array

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't write to ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"

    [[ -w "${path}" ]] || PROBLEMS+=("${msg}") 
}


function source_enabled_confs() {
    ## source conf snippets in ./confs-enabled/*.conf while
    ## substituting the variables in those conf files with the ones
    ## generated in this script.

    [[ ! -z "${DEBUG}" ]] && debug "entering \`${FUNCNAME}' with arguments \`$@'"

    for conf_file in ${CONFS_ENABLED}; do
	echo -e "\n## start processing \`${conf_file##*/}'"
	while IFS='' read -r line ; do
	    #debug "### line: ${line}"
	    if [[ "${line}" =~ \$\{([a-zA-Z_][a-zA-Z_0-9]*)\} ]] ; then
		## match the variable in the template (eg the complete `${VARIABLE}' string) 
		var_template=${BASH_REMATCH[1]}
		#debug "### vt: ${var_template}"
		expandend_value=var_template
		local ev="${!expandend_value}"
		#debug "### ev: ${ev}"
		line=${line//\$\{${var_template}\}/${!ev}}
	    fi
	    ## skip commented lines
	    ## create trimmed version of line
	    if [[ -z ${INCLUDE_COMMENTS} ]]; then
		trimmed=$([[ "${line}" =~ [[:space:]]*([^[:space:]]|[^[:space:]].*[^[:space:]])[[:space:]]* ]]; echo -n "${BASH_REMATCH[1]}")

		if [[ "${trimmed#\#*}" = "${trimmed}" ]]; then
		    if [[ ! -z "${trimmed}" ]]; then
			echo -e "${line}"
		    fi
		fi
	    else
		echo -e "${line}"
	    fi
	done <${conf_file}
	echo -e "## done processing"
    done
}

function conf_header() {
    ## construct the byline for the configuration file

    formatted_date="$(date -Is)"
    app_url="https://github.com/ronalde/${APP_NAME}/"

    printf "\n%s\n%s begin of %s\n%s created by \`%s' on %s.\n%s see: %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" "${MSG_CONF_TITLE}" \
	"${MSG_CONF_SEP}" "${APP_NAME}" "${formatted_date}" \
	"${MSG_CONF_SEP}" "${app_url}" "${MSG_CONF_LINESEP}\n"

}

function conf_footer() {
    printf "\n\n%s\n%s end of %s\n%s\n" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" "${MSG_CONF_TITLE}" "${MSG_CONF_LINESEP}"
}

### program start

APP_NAME="mpd-configure"

## store the current directory 
SCRIPT_DIR=$(dirname $0)

ALSA_CAPABILITIES_FILE="alsa-capabilities"
ALSA_CAPABILITIES_SCRIPT="${SCRIPT_DIR}/${ALSA_CAPABILITIES_FILE}"

[[ -f "${ALSA_CAPABILITIES_SCRIPT}" ]] && \
    . "${ALSA_CAPABILITIES_SCRIPT}" || \
    die "required script \`${ALSA_CAPABILITIES_SCRIPT}' not found"

CONFS_ENABLED=${SCRIPT_DIR}/confs-enabled/*.conf

## global indexed arrays that will be filled from `alsacapabilities.sh'
declare -a ALSA_AIF_HWADDRESSES=()
declare -a ALSA_AIF_DEVLABELS=()
declare -a ALSA_AIF_LABELS=()

## for storing (potential) problems 
declare -a PROBLEMS=()

## users may change the global variables that this script uses in the
## file `mpd-configure.conf' or specify them on the command line when
## starting this script, eg: 
##  MPD_HOST="myhostname" ./mpd-configure

## source the config file if its present
PREFERENCES_FILE="${SCRIPT_DIR}/mpd-configure.conf"
[[ -f "${PREFERENCES_FILE}" ]] && \
    source "${PREFERENCES_FILE}"

## global variable for holding the contents of the conf file
CONF_CONTENTS=""

## general messages and fixed strings
MSG_MPD_CONFFILE="mpd configuration file"
MSG_DONE="\n\n${MSG_MPD_CONFFILE} saved in \`${MPD_CONFFILE}'.\n"
MSG_DONE_DRYRUN="\ndryrun mpd configuration done (not saved).\n"
MSG_TAB=" * "
MSG_MARGIN="${MSG_TAB//\*/ }"
MSG_CONF_LINESEP="$(printf '#%.0s' {1..76})"
MSG_CONF_SEP="###"
MSG_CONF_TITLE="mpd configuration file"


## check if needed programs are available
CMD_APLAY=$(which aplay || command_not_found "aplay" "alsa-utils")

## if not set, default to 0.0.0.0
CONF_MPD_HOST="${CONF_MPD_HOST:-0.0.0.0}"

## pass limits to the alsa-capabilities script
if [[ ! -z ${LIMIT_INTERFACE_TYPE} ]]; then
    case ${LIMIT_INTERFACE_TYPE} in
	"analog")
	    OPT_LIMIT_AO="True" ;;
	"digital")
	    OPT_LIMIT_DO="True" ;;
	"usb"|"uac")
	    OPT_LIMIT_UO="True" ;;
    esac
fi

[[ ! -z ${LIMIT_INTERFACE_FILTER} ]] && OPT_FILTER="${LIMIT_INTERFACE_FILTER}"

## display (potential) problematic situations, like no right access to
## files and directories

[[ ! -z "${DEBUG}" ]] && \
    debug "\nPotential problems for the current configuration:\n${PROBLEMS[@]}\n"

## get an array with available alsa hardware addresses
fetch_alsa_hwaddresses

### paths

if [[ -z ${MPD_MUSICDIR} ]]; then
    ## get `music' directory from xdg
    XDG_USER_USERDIRS=${HOME}/.config/user-dirs.dirs
    ## source the user settings if present to fill XDG_MUSIC_DIR
    [[ -f ${XDG_USER_USERDIRS} ]] && source ${XDG_USER_USERDIRS}
    ## if empty revert to HOME
    [[ -z ${XDG_MUSIC_DIR} ]] && XDG_MUSIC_DIR=${HOME}
fi

## defaults to $XDG_MUSIC_DIR
CONF_MPD_MUSICDIR="${MPD_MUSICDIR:-${XDG_MUSIC_DIR}}"
check_readable_path "${MPD_MUSICDIR}" "music directory" "listen to music"

## working directory for mpd
mpd_homedir="${CONF_MPD_HOMEDIR:-${HOME}/.mpd}"
check_readable_path "${mpd_homedir}" "mpd home directory" "use ${MSG_MPD_CONFFILE}"
check_writeable_path "${mpd_homedir}" "mpd home directory" "store ${MSG_MPD_CONFFILE}"
## where to store data
MPD_DATADIR="${MPD_DATADIR:-${mpd_homedir}}"
CONF_MPD_PLAYLISTDIR="${MPD_PLAYLISTDIR:-${MPD_DATADIR}/playlists}"
check_readable_path "${MPD_PLAYLISTDIR}" "playlist directory" "use playlists"
check_writeable_path "${MPD_PLAYLISTDIR}" "playlist directory" "change or create playlists"
CONF_MPD_DBFILE="${MPD_DBFILE:-${MPD_DATADIR}/tag_cache}"
check_readable_path "${MPD_DBFILE}" "database file" "use mpd"
check_writeable_path "${MPD_DBFILE}" "database file" "store changes in mpd"
CONF_MPD_LOGFILE="${MPD_LOGFILE:-${MPD_DATADIR}/mpd.log}"
check_writeable_path "${MPD_LOGFILE}" "log file" "start or use mpd"
CONF_MPD_PIDFILE="${MPD_PIDFILE:-${MPD_DATADIR}/pid}"
check_writeable_path "${MPD_PIDFILE}" "PID file" "start, stop or restart mpd using service daemon"
CONF_MPD_STATEFILE="${MPD_STATEFILE:-${MPD_DATADIR}/state}"

## zeroconf
CONF_ZEROCONF_LABEL="${ZEROCONF_NAME:-MPD through ${ALSA_AIF_DEVLABEL}}"

## store conf snippets in CONF_CONTENTS
#network_conf
#paths_conf
#audio_conf
#misc_conf
#lastfm_conf
#zeroconf_conf
header="$(conf_header)"
footer="$(conf_footer)"
jaap="${header}$(source_enabled_confs)${footer}"
echo -e "${jaap}"


## print the footer 
#store_conf "${msg_conf_end}"

## displays the contents of CONF_CONTENTS or write them to MPD_CONFFILE if set
[[ -z "${MPD_CONFFILE}" ]] && \
    echo -e "${CONF_CONTENTS}" ||  \
    write_conffile

### done
