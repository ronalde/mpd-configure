#!/usr/bin/env bash
##
## `mpd-configure' is a bash script that tries to ease the
## configuration of mpd for audiophile purposes.
##
##  Copyright (C) 2015 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## The script, helpers and documentation are published at 
## https://github.com/ronalde/mpd-configure
## 
## Also see `README'

LANG=C
### defaults
## default network address to listen to
CONF_MPD_NETWORK_ADRESS_DEFAULT="0.0.0.0"
## default network port to listen on
CONF_MPD_NETWORK_PORT_DEFAULT="6600"
## default maximum number of files in music directory
MAX_PLAYLIST_LENGTH_DEFAULT="16384"


function echo_stderr() {
    ## prevent messages from mixing with the actual output of the
    ## script (ie stdout)

    echo -e "$@" 1>&2; 
}

function die() {
    ## exit with error while displaying an error message $1

    echo_stderr "ERROR: $@"
    exit 1
}

function debug_configure() {
    echo_stderr "DEBUG *   ${1}"    
}


function write_error() {
    ## the conf file or dir ($1) is not writable and exists if ($2) is set. 
    ## echo the contents of the generated conf file to std_out and
    ## exit with error

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    path_notwritable="${1}"
    path_exists="${2}"

    if [[ -z ${path_exists} ]]; then
	msg="\n${MSG_TAB}can't write to ${path_notwritable}"
    else
	msg="\n${MSG_TAB}although ${path_notwritable} exists, it is not writable."
    fi
    msg="${msg}\n${MSG_MARGIN}the ${MSG_MPD_CONFFILE} can't be saved."
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "${msg}\n${MSG_TAB}Will display the generated contents instead."

    inform "${CONF_CONTENTS}"
    die "${msg}"
}


function really_write() {
    ## writes the contents of CONF_CONTENTS to MPD_CONFFILE

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    if [[ -z "${DRYRUN}" ]]; then
	## do the actual writing
	echo -e "${CONF_CONTENTS}" > "${MPD_CONFFILE}" && \
	    msg="${MSG_DONE}" || die "Could not write to \`${MPD_CONFFILE}': $?"
    else
	## dryrun enabled: display the contents of mpd_conffile
	msg="DRYRUN: Not writing to ${MPD_CONFFILE}: \
\n${CONF_CONTENTS} \
\n${MSG_DONE_DRYRUN}"
    fi

    ## display the result
    printf "${msg}"

    [[ ! -z "${DEBUG}" ]] && debug_configure "result: \`${msg}'"

}

function write_conffile() {
    ## prepares to write to the mpd configuration file.

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    msg=""

    mpd_conf_dir="$(dirname ${MPD_CONFFILE})"

    if [[ ! -d "${mpd_conf_dir}" ]]; then
	[[ ! -z "${DEBUG}" ]] && debug_configure "conf dir does not exist, try to create it"
	dirok="$(mkdir -p "${mpd_conf_dir}" 2>&1 >/dev/null)"
	[[ ! -z ${dirok} ]] && \
	    msg="Can't create directory \`${mpd_conf_dir}' which is necessary for storing \
\n${MSG_MARGIN}${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
    else
	## conf dir exists, check if it writable
	[[ -w "${mpd_conf_dir}" ]] || \
	    msg="No write permission in directory \`${mpd_conf_dir}'."
    fi

    ## exit with error if this failed
    [[ ! -z "${msg}" ]] && die "\n${MSG_TAB}${msg}"

    [[ ! -z "${DEBUG}" ]] && debug_configure "mpd_conf_dir ok: \`${mpd_conf_dir}'"

    if [[ -f "${MPD_CONFFILE}" ]]; then

	## conf file exists, check if its writable
	if [[ ! -w "${MPD_CONFFILE}" ]]; then
	    ## not writable, exit with error 
	    msg="\n${MSG_TAB}Existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' is present, \
but is not writable."
	    die "${msg}"
	fi

	## is writable, prompt to overwrite
	msg="${MSG_TAB}Original ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}' exists."
	inform "${msg}"
	## only prompt when OVERWRITE_EXISTING_CONFFILE is not set
	[[ ! -z "${DEBUG}" ]] && \
	    debug_configure "OVERWRITE_EXISTING_CONFFILE: \`${OVERWRITE_EXISTING_CONFFILE}'"
	if [[ -z ${OVERWRITE_EXISTING_CONFFILE} ]]; then
	    prompt="${MSG_MARGIN}>> Overwrite it?: "
	    overwrite="$(read -e -p "${prompt}" -i "Yes" overwrite && \
echo -e "${overwrite}")"
	    ## if prompt returns (downcased) `yes' then overwrite the file
	    if ! [[ "${overwrite,,}" = "yes" ]]; then
		## user choose no to overwrite; exit with message
		inform "Not overwriting existing ${MSG_MPD_CONFFILE} \`${MPD_CONFFILE}'."
		exit 0
	    fi
	fi
    fi

    ## do the actual writing
    fileok="$(really_write)"

}


function command_not_found() {
    ## give installation instructions when a command is not available
    ## and exit with error

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    command="$1"
    package="$2"
    instructions="$3"
    msg="Error: command \`${command}' not found. "

    [[ -z "${instructions}" ]] && \
	msg+="Users of Debian (or deratives, like Ubuntu) can install it with: \
\n sudo apt-get install ${package}" || \
	msg+="${instructions}"

    die "${msg}"

}

function fetch_alsa_hwaddresses() {
    ## use alsa-capabilities script to get alsa output interfaces; if
    ## one interface is found, use that, otherwise display all of them
    ## and ask the user which to use.
    ##
    ## stores the hardware address and label in global variables
    ## ALSA_AIF_HWADDRESS and ALSA_AIF_DEVLABEL.

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    ## prompt when multiple alsa interfaces are found
    msg_multiple_alsahw="${MSG_TAB}Multiple interfaces found."

    ## when more than one matching output device is found and
    ## USER_PROMPTS is not set, prompt the user to select one,
    ## defaults to the first device found.

    ## put the result of alsa-capabilities in an array
    return_alsa_interface

    [[ ! -z ${DEBUG} ]] && \
	debug_configure "number of returned alsa interfaces: ${#ALSA_AIF_HWADDRESSES[@]}"

    ## set first interface found as default
    selectedkey=0
    default_aif_hwaddress="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"

    if [[ ${#ALSA_AIF_HWADDRESSES[@]} -gt 1 ]]; then
	if [[ -z "${USER_PROMPTS}" ]]; then
	    ## display instructions for multiple interfaces and prompt
	    #echo_stderr "${msg_multiple_alsahw}"
	    #prompt="${MSG_MARGIN}>> Interface to use: "
	    msg_prompt=">> Specify the interface to use and press [ENTER] to confirm: "
	    prompt="$(printf '%s\n%s' "${msg_multiple_alsahw}" \
"${MSG_MARGIN}${msg_prompt}")"
	    ## prompt the user to select a interface
	    alsa_aif_hwaddress="$(read -e -p "${prompt}" \
-i "${default_aif_hwaddress}" alsa_aif_hwaddress && \
echo -e "${alsa_aif_hwaddress}")"

	    for key in "${!ALSA_AIF_HWADDRESSES[@]}"; do
		## set the user selected key and exit loop
		if [[ "${ALSA_AIF_HWADDRESSES[$key]}" = "${alsa_aif_hwaddress}" ]]; then
		   let selectedkey=${key}
		   break
		fi
	    done
	fi
    fi

    ## store the hardware address and label for usage in audio_conf
    CONF_ALSA_AIF_HWADDRESS="${ALSA_AIF_HWADDRESSES[${selectedkey}]}"
    CONF_ALSA_AIF_DEVLABEL="${ALSA_AIF_DEVLABELS[${selectedkey}]} - \
${ALSA_AIF_LABELS[${selectedkey}]}"
}


function check_readable_path() {
    ## checks if path ($1), needed for ($2) is readable, or adds
    ## problem description ($2) to problems array

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$*'"
    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't access or read ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"
    [[ -d "${path}" || -f "${path}" ]] || PROBLEMS+=("${msg}") 
}


function check_writeable_path() {
    ## checks if path ($1), needed for ($2) is writeable, or adds
    ## problem description ($2) to problems array

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'\n"

    path="$1"
    purpose="$2"
    problem="$3"

    msg="\n${MSG_TAB}Can't write to ${purpose} \`${path}',\
\n${MSG_MARGIN}you won't be able to ${problem}.\n"

    [[ -w "${path}" ]] || PROBLEMS+=("${msg}") 
}

function parse_configuration_line() {

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    line="$@"

    ## construct the regular expression for configuration items
    local brm='([[:alpha:][:alnum:]_]*)[[:space:]]*\"\$\{(.*)\}\"$'
    ## match the regexp
    if [[ "${line}" =~ ${brm} ]] ; then
	## line is mpd configuration: `config_value "${...}"'
	
	## given a line of `config_value "${...}"'
	## the name of the variable with or without a default value: `...'
	var_part="${BASH_REMATCH[2]}"
	var_template="${var_part}"
	var_search="${var_template}"
	if [[ "${var_part}" =~ ^(.*):-(.*)$ ]]; then
	    ## the line contains a variable with default value:
	    ##  `config_value "${VARNAME:-default_value}"'

	    ## store the variable name: `VARNAME'
	    var_template="${BASH_REMATCH[1]}"
	    var_value="${BASH_REMATCH[2]}"
	    ## the variable name including its default value `VARNAME:-default_value'
	    var_search="${BASH_REMATCH[1]}:-${BASH_REMATCH[2]}"
	fi
	## assign the name of the variable (`VARNAME') to $expanded_name
	exp_name=var_template
	## assign the value of the variable (`$VARNAME') to $expanded_value
	local exp_value="${!exp_name}"
	
	## return the line with its real/expanded value
	if [[ ! -z "${!exp_value}" ]]; then
	    printf "%s" "${line//\$\{${var_search}\}/${!exp_value}}"
	else
	    [[ -z ${INCLUDE_COMMENTS} ]] && \
		printf "" || \
		printf "# %s (value not set)" "${line//\$\{${var_search}\}/${!exp_value}}"
	    [[ ! -z "${DEBUG}" ]] && \
		debug_configure "not writing empty configuration setting \`${var_template}'."
	fi
    else
	## a normal line; return it
	printf "%s" "${line}"
    fi
    
}

function source_enabled_confs() {
    ## source conf snippets in ./confs-enabled/*.conf while
    ## substituting the variables in those conf files with the ones
    ## generated in this script.

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    ## temporary file needed to source enabled configuration snippets files
    tempconfs="$(mktemp)"

    ## fill the file with all configuration lines from `confs-enabled/*.conf`
    sed 's/^\([[:alnum:][:space:]_]*\)[[:space:]]*"\${\(.*\):-\(.*\)}"$/export \2="\${\2:-\3}"/' \
	${SCRIPT_DIR}/confs-enabled/*.conf | grep -E ^export > "${tempconfs}"

    ## source it (needed for variable expansion)
    source "${tempconfs}" || die "could not source \`${tempconfs}'"

    ## remove it when DEBUG_CONFIGURE is not set
    [[ ! -z "${DEBUG}" ]] && \
	debug_configure "sourced configuration values stored in \`${tempconfs}'.\n" || \
	rm "${tempconfs}"

    ## iterate each file
    for conf_file in ${CONFS_ENABLED}; do

	## check if the symlink points to a valid file
	isvalid="$(readlink -e "${conf_file}")"

	## process the next one if the symlink is broken 
	if [[ -z "${isvalid}" ]]; then
	    [[ ! -z "${DEBUG}" ]] && debug_configure "not a valid symlink \`${conf_file}'"
	    continue
	fi

	## the file exists, parse it
	printf "\n## start processing \`%s'\n" "${conf_file##*/}"

	## iterate each line
	while IFS='' read -r line ; do

	    ## skip commented lines
	    ## create trimmed version of line
	    if [[ -z ${INCLUDE_COMMENTS} ]]; then
		trimmed=$([[ "${line}" =~ [[:space:]]*([^[:space:]]|[^[:space:]].*[^[:space:]])[[:space:]]* ]]; echo -n "${BASH_REMATCH[1]}")

		if [[ "${trimmed#\#*}" = "${trimmed}" ]]; then
		    if [[ ! -z "${trimmed}" ]]; then
			## parse the line
			line="$(parse_configuration_line "${line}")"
			
			local interpreted_line="${!line}"
			## original code
			[[ ! -z "${line}" ]] && \
			    printf "%s\n" "${line}"
		    fi
		fi
	    else
		line="$(parse_configuration_line "${line}")"
		echo -e "${line}"
	    fi
	done <${conf_file}
	echo -e "## done processing"
    done
}

function perform_automagic() {
    ### automagic configuration stuff

    [[ ! -z "${DEBUG}" ]] && \
	debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    ## client limits
    ## if the directory specified in `CONF_MPD_MUSICDIR` is
    ## accessible, calculate the number of audio files and double that
    ## for `max_playlist_length` parameter.
    
    default_length=${MAX_PLAYLIST_LENGTH_DEFAULT}
    nr_musicfiles=0

    if [[ -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "G_CLIENTLIMITS_MAXPLAYLISTLENGTH not set, trying to count the number of music files ..."
	## setting not configured
	if [[ -d "${CONF_MPD_MUSICDIR}" ]]; then
	    ## music dir exists; calculate number of files
	    ## TODO: add permission errors to errorlog
    	    ## ls without stat() calls is much faster than find or bash globbing, thanks 
	    ## http://stackoverflow.com/questions/1427032/fast-linux-file-count-for-a-large-number-of-files
	    let nr_musicfiles=$(ls -fR  "${CONF_MPD_MUSICDIR}" 2>/dev/null| wc -l)

	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Done counting, nr of files found: \`${nr_musicfiles}'"

	    let double_nr_musicfiles=( ${nr_musicfiles} * 2 )
	    [[ ${double_nr_musicfiles} -gt ${default_length} ]] && \
		G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${double_nr_musicfiles} || \
		G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${default_length}
	else
	    ## music dir not available; use default
	    G_CLIENTLIMITS_MAXPLAYLISTLENGTH=${default_length}
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Music dir not available, nr of files set to default: \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'."
	fi
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "G_CLIENTLIMITS_MAXPLAYLISTLENGTH set to \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'."

    fi
    
    ## if empty set `G_CLIENTLIMITS_MAXCOMMANDLISTSIZE` to 1/8 of
    ## `G_CLIENTLIMITS_MAXPLAYLISTLENGTH`
    [[ -z ${G_CLIENTLIMITS_MAXCOMMANDLISTSIZE} && \
	! -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]] && \
	let G_CLIENTLIMITS_MAXCOMMANDLISTSIZE=( ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} / 8 )
    
    ## if empty, set `MAXOUTPUTBUFFERSIZE` to 1/2 of
    ## `G_CLIENTLIMITS_MAXPLAYLISTLENGTH`
    [[ -z ${G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE} && \
	! -z ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} ]] && \
	let G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE=( ${G_CLIENTLIMITS_MAXPLAYLISTLENGTH} / 2 )
    
    if [[ ! -z "${DEBUG}" ]]; then
	debug_configure "G_CLIENTLIMITS_MAXPLAYLISTLENGTH: \`${G_CLIENTLIMITS_MAXPLAYLISTLENGTH}'"
	debug_configure "G_CLIENTLIMITS_MAXCOMMANDLISTSIZE: \`${G_CLIENTLIMITS_MAXCOMMANDLISTSIZE}'"
	debug_configure "G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE: \`${G_CLIENTLIMITS_MAXOUTPUTBUFFERSIZE}'"
    fi
    
    ## get network name for zeroconf
    if [[ -z "${G_ZEROCONF_ZEROCONFNAME}" ]]; then
	## `G_ZEROCONF_ZEROCONFNAME` is not set; set default zeroconf label 
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "G_ZEROCONF_ZEROCONFNAME not set  ..."
	
	hostname_string=""
	## only try to get hostname if it isn't link local
	if [[ ! "${CONF_MPD_NETWORK_ADRESS}" =~ "127" ]] || [[ "${CONF_MPD_NETWORK_ADRESS}" != "0.0.0.0" ]] || \
	    [[ ! "${CONF_MPD_NETWORK_ADRESS}" =~ "*::*"  ]]; then
	    ## mpd is configured to use a 'real' ip address; try to get fqdn name
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "mpd is configured to use a 'real' ip address ..."
	    if [[ -x $(which hostname) ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "hostname command is available"
		hostname="$(hostname --fqdn)"
		if [[ -z "${hostname}" ]]; then
		    ## fallback to 'short' hostname
		    hostname="$(hostname)"
		    [[ ! -z ${DEBUG} ]] && \
			debug_configure "mpd hostname set by script and hostname to short name \`${hostname}'."
		else
		    [[ ! -z ${DEBUG} ]] && \
			debug_configure "mpd hostname set by script and hostname to fqdn \`${hostname}'."
		fi
	    else
		# use bash's internal hostname
		hostname="${HOSTNAME}"
		[[ ! -z ${DEBUG} ]] && \
		    debug_configure "mpd hostname set by script to HOSTNAME variable of bash: \`${hostname}'."
	    fi
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "G_ZEROCONF_ZEROCONFNAME set by user to \`${G_ZEROCONF_ZEROCONFNAME}'."

	fi
	
	## set string to use if hostname contains something
	[[ ! -z ${hostname} ]] && hostname_string="on ${hostname} "
	
	G_ZEROCONF_ZEROCONFNAME="${ZEROCONF_NAME:-MPD \
${hostname_string}through ${CONF_ALSA_AIF_DEVLABEL}}"
	
    fi

}

function get_mpd_musicdir() {
    ### get and check music dir

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"

    ## check if user set the music dir configuration parameters
    if [[ ! -z "${CONF_MPD_MUSICDIR}" ]]; then
        G_PATHS_MUSICDIRECTORY="${CONF_MPD_MUSICDIR}"
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_MUSICDIR set by user to \`${G_PATHS_MUSICDIRECTORY}'."
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_MUSICDIR not set by user ..."
        
	## try getting the `MUSIC' directory from XDG and use that,
	## otherwise user current dir
	CMD_XDGUSERDIR=$(which xdg-user-dir)
	if [[ $? -eq 0 ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "CMD_XDGUSERDIR found in path: \`${CMD_XDGUSERDIR}'."
	    xdg_music_dir="$(${CMD_XDGUSERDIR} MUSIC)"
	    if [[ "$?" -eq 0 ]]; then
		G_PATHS_MUSICDIRECTORY="${xdg_music_dir}"
		[[ ! -z ${DEBUG} ]] &&  \
		    debug_configure "G_PATHS_MUSICDIRECTORY set to xdg-music-dir (${G_PATHS_MUSICDIRECTORY})"
	    else
		[[ ! -z ${DEBUG} ]] &&  \
		    debug_configure "G_PATHS_MUSICDIRECTORY left empty (${G_PATHS_MUSICDIRECTORY})"
            fi
	else
	    if [[ ! -z ${DEBUG} ]]; then
		debug_configure "CMD_XDGUSERDIR not found in path."
		debug_configure "G_PATHS_MUSICDIRECTORY left empty (${G_PATHS_MUSICDIRECTORY})"
	    fi
	fi
    fi
    
    ## use current dir if still empty
    if [[ -z ${G_PATHS_MUSICDIRECTORY} ]]; then
      G_PATHS_MUSICDIRECTORY="$(pwd)"
      [[ ! -z ${DEBUG} ]] && \
	  debug_configure "G_PATHS_MUSICDIRECTORY set to current dir: \`${G_PATHS_MUSICDIRECTORY}'."
    fi 
    
    check_readable_path "${G_PATHS_MUSICDIRECTORY}" "music directory" "listen to music"
    
}

function get_mpd_userdir() {
    ### get and check working directory for mpd

    [[ ! -z "${DEBUG}" ]] && debug_configure "entering \`${FUNCNAME}' with arguments \`$@'"
  
    ## if `CONF_MPD_HOMEDIR` not set by user use `XDG_CONFIG_MPDDIR`
    if [[ -z ${CONF_MPD_HOMEDIR} ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_HOMEDIR not set, trying to get xdg_config_dir ..."
       ## use user xdg config dir or current path
	XDG_CONFIG_DIR="${HOME}/.config"
	if [[ -d ${XDG_CONFIG_DIR} ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "XDG_CONFIG_DIR found: \`${XDG_CONFIG_DIR}'."
	else   
	    XDG_CONFIG_DIR=$(pwd)
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "XDG_CONFIG_DIR not found, using current dir: \`${XDG_CONFIG_DIR}'."
	fi
        ## set default path
	CONF_MPD_HOMEDIR=${XDG_CONFIG_DIR}/mpd
	[[ ! -z ${DEBUG} ]] && \
		debug_configure "CONF_MPD_HOMEDIR set by script to: \`${CONF_MPD_HOMEDIR}'."
	
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_HOMEDIR set by user to \`${CONF_MPD_HOMEDIR}'."
    fi
    
    ## check if it is accessible
    check_readable_path "${CONF_MPD_HOMEDIR}" "mpd home directory" \
	"use ${MSG_MPD_CONFFILE}"
    check_writeable_path "${CONF_MPD_HOMEDIR}" "mpd home directory" \
	"store ${MSG_MPD_CONFFILE}"
    
    ## where to store data
    MPD_DATADIR="${MPD_DATADIR:-${CONF_MPD_HOMEDIR}}"
    CONF_MPD_PLAYLISTDIR="${MPD_PLAYLISTDIR:-${MPD_DATADIR}/playlists}"
    check_readable_path "${MPD_PLAYLISTDIR}" "playlist directory" "use playlists"
    check_writeable_path "${MPD_PLAYLISTDIR}" "playlist directory" \
	"change or create playlists"
    CONF_MPD_DBFILE="${MPD_DBFILE:-${MPD_DATADIR}/tag_cache}"
    check_readable_path "${MPD_DBFILE}" "database file" "use mpd"
    check_writeable_path "${MPD_DBFILE}" "database file" "store changes in mpd"
    CONF_MPD_LOGFILE="${MPD_LOGFILE:-${MPD_DATADIR}/mpd.log}"
    check_writeable_path "${MPD_LOGFILE}" "log file" "start or use mpd"
    CONF_MPD_PIDFILE="${MPD_PIDFILE:-${MPD_DATADIR}/pid}"
    check_writeable_path "${MPD_PIDFILE}" "PID file" \
	"start, stop or restart mpd using service daemon"
    CONF_MPD_STATEFILE="${MPD_STATEFILE:-${MPD_DATADIR}/state}"
    check_writeable_path "${MPD_STATEFILE}" "state file" \
	"store mpd running status"
    CONF_MPD_STICKERFILE="${MPD_STICKERFILE:-${MPD_DATADIR}/sticker}"
    check_writeable_path "${MPD_STICKERFILE}" "sticker file" \
	"store dynamic user data"   
    
}


function conf_header() {
    ## construct the byline for the configuration file

    formatted_date="$(date -Is)"
    app_url="https://github.com/ronalde/${APP_NAME}/"

    printf "\n%s\n%s begin of %s\n%s created by \`%s' on %s.\n%s see: %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" "${MSG_CONF_TITLE}" \
	"${MSG_CONF_SEP}" "${APP_NAME}" "${formatted_date}" \
	"${MSG_CONF_SEP}" "${app_url}" "${MSG_CONF_LINESEP}\n"

}

function conf_footer() {
    printf "\n\n%s\n%s end of %s\n%s" \
	"${MSG_CONF_LINESEP}" "${MSG_CONF_SEP}" \
	"${MSG_CONF_TITLE}" "${MSG_CONF_LINESEP}\n"
}


function do_configure() {

    ## get an array with available alsa hardware addresses
    fetch_alsa_hwaddresses
    if [[ $? -ne 0 ]]; then
	die "error in fetch_alsa_hwaddresses"
    fi
    ## get and check paths
    get_mpd_musicdir
    if [[ $? -ne 0 ]]; then
	die "error in get_mpd_musicdir"
    fi

    get_mpd_userdir
    if [[ $? -ne 0 ]]; then
	die "error in get_mpd_userdir"
    fi

    ### perform automagic configuration
    perform_automagic
    if [[ $? -ne 0 ]]; then
	die "error in perform_automagic"
    fi


    ## store conf snippets in `CONF_CONTENTS`
    header="$(conf_header)"
    footer="$(conf_footer)"

    ## iterate each line in enabled files in `confs-enabled/*.conf`
    CONF_CONTENTS="${header}$(source_enabled_confs)${footer}"

    ## displays the contents of CONF_CONTENTS or write them to
    ## `MPD_CONFFILE` if set
    [[ -z "${MPD_CONFFILE}" ]] && \
	printf "%s\n" "${CONF_CONTENTS}" ||  \
	write_conffile

}

### program start

APP_NAME="mpd-configure"

## check if we're re being sourced
SOURCED=""

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    SOURCED=True 
    ## store the current directory 
    SCRIPT_DIR=$(pwd)
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "script ${0} is being sourced; using SCRIPT_DIR \`${SCRIPT_DIR}'."
else
    ## store the directory in which the script resides
    SCRIPT_DIR=$(dirname $0)
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "script ${0} is being run; using SCRIPT_DIR \`${SCRIPT_DIR}'."
fi

if [[ ! -z ${DEBUG} ]]; then
    debug_configure "debugging turned on by user."
    debug_configure "Lines marked \`DEBUG *' depict this script "
    debug_configure "Lines marked \`DEBUG ***' depict alsa-capabilities helper script "
fi

## no problem if GNU find is not found; fail silently


## source own helper script if found
ALSA_CAPABILITIES_FILE="alsa-capabilities"
ALSA_CAPABILITIES_SCRIPT="${SCRIPT_DIR}/${ALSA_CAPABILITIES_FILE}"

if [[ -f "${ALSA_CAPABILITIES_SCRIPT}" ]]; then 
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "will source ALSA_CAPABILITIES_SCRIPT \`${ALSA_CAPABILITIES_SCRIPT}' ..."
    source "${ALSA_CAPABILITIES_SCRIPT}" 
    if [[ $? -eq 0 ]]; then
	[[ ! -z ${DEBUG} ]] && debug_configure "... done."
    else
	die "error sourcing ALSA_CAPABILITIES_SCRIPT \`${ALSA_CAPABILITIES_SCRIPT}'."
    fi
else
    die "required script \`${ALSA_CAPABILITIES_SCRIPT}' not found."
fi

## ugly temporary hack; see github issue #8
set +u
set +e

## list of enabled configuration snippet files
CONFS_ENABLED=${SCRIPT_DIR}/confs-enabled/*.conf
[[ ! -z ${DEBUG} ]] && debug_configure "CONFS_ENABLED: \`${CONFS_ENABLED}'."

## global indexed arrays that will be filled from `alsacapabilities.sh'
declare -a ALSA_AIF_HWADDRESSES=()
declare -a ALSA_AIF_DEVLABELS=()
declare -a ALSA_AIF_LABELS=()

## for storing (potential) problems 
declare -a PROBLEMS=()

## source the config file if its present
PREFERENCES_FILE="${SCRIPT_DIR}/mpd-configure.conf"
if [[ -f "${PREFERENCES_FILE}" ]]; then
    source "${PREFERENCES_FILE}"
    [[ ! -z ${DEBUG} ]] && debug_configure "PREFERENCES_FILE sourced: \`${PREFERENCES_FILE}'"
else
    [[ ! -z ${DEBUG} ]] && debug_configure "PREFERENCES_FILE \`${PREFERENCES_FILE}' not found."
fi

## for backwards compatibility
[[ ! -z "${CONF_ZEROCONF_ENABLED}" ]] || [[ ! -z "${ENABLE_LASTFM}" ]] && \
    die "configuration settings \`CONF_ZEROCONF_ENABLED' and
    \`ENABLE_LASTFM' \nare no longer valid. please consult \`README'."

## for backwards compatibility
if [[ ! -z "${CONF_MPD_HOST}" ]] || [[ ! -z "${CONF_MPD_NETWORK_ADRESS}" ]]; then
    if [[ ! -z "${CONF_MPD_HOST}" ]] && [[ ! -z "${CONF_MPD_NETWORK_ADRESS}" ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    "Both CONF_MPD_HOST and CONF_MPD_NETWORK_ADRESS set by user, using the latter"
	G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
	[[ ! -z ${DEBUG} ]] && \
	    debug_configure "CONF_MPD_NETWORK_ADRESS set by user to: \`${CONF_MPD_NETWORK_ADRESS}'."
    else
	
	if [[ ! -z "${CONF_MPD_HOST}" ]]; then
	    CONF_MPD_NETWORK_ADRESS="${CONF_MPD_HOST}"
	    G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "CONF_MPD_NETWORK_ADRESS set by user through CONF_MPD_HOST to: \`${CONF_MPD_HOST}'."
	fi
	if [[ ! -z "${CONF_MPD_NETWORK_ADRESS}" ]]; then
	    G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "CONF_MPD_NETWORK_ADRESS set by user to: \`${CONF_MPD_NETWORK_ADRESS}'."
	fi
    fi
else
    ## both not set; default
    CONF_MPD_NETWORK_ADRESS="${CONF_MPD_NETWORK_ADRESS_DEFAULT}"
    G_NETWORK_BINDTOADDRESS="${CONF_MPD_NETWORK_ADRESS}"
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "CONF_MPD_NETWORK_ADRESS set to default: \`${CONF_MPD_NETWORK_ADRESS}'."
fi

if [[ ! -z "${CONF_ZEROCONF_LABEL}" ]]; then 
    G_ZEROCONF_ZEROCONFNAME="${CONF_ZEROCONF_LABEL}"
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "G_ZEROCONF_ZEROCONFNAME set to CONF_ZEROCONF_LABEL: \`${CONF_ZEROCONF_LABEL}'"
fi
## global variable for holding the contents of the conf file
CONF_CONTENTS=""

## general messages and fixed strings
MSG_MPD_CONFFILE="mpd configuration file"
MSG_DONE="\n\n${MSG_MPD_CONFFILE} saved in \`${MPD_CONFFILE}'.\n"
MSG_DONE_DRYRUN="\ndryrun mpd configuration done (not saved).\n"
MSG_TAB=" * "
MSG_MARGIN="${MSG_TAB//\*/ }"
MSG_CONF_LINESEP="$(printf '#%.0s' {1..76})"
MSG_CONF_SEP="###"
MSG_CONF_TITLE="mpd configuration file"


## pass limits to the alsa-capabilities script
if [[ ! -z ${LIMIT_INTERFACE_TYPE} ]]; then
    case ${LIMIT_INTERFACE_TYPE} in
	"analog")
	    OPT_LIMIT_AO="True"
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Only process analog interfaces (OPT_LIMIT_AO): ${OPT_LIMIT_AO}"
	    ;;
	
	"digital")
	    OPT_LIMIT_DO="True" 
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Only process digital interfaces (OPT_LIMIT_DO): ${OPT_LIMIT_DO}"
	    ;;
	"usb"|"uac")
	    OPT_LIMIT_UO="True" 
	    [[ ! -z ${DEBUG} ]] && \
		debug_configure "Only process usb interfaces (OPT_LIMIT_UO): ${OPT_LIMIT_UO}"
	    ;;
    esac
fi

if [[ ! -z ${LIMIT_INTERFACE_FILTER} ]]; then
    OPT_FILTER="${LIMIT_INTERFACE_FILTER}"
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "OPT_FILTER set to LIMIT_INTERFACE_FILTER: \`${LIMIT_INTERFACE_FILTER}'"
fi

## display (potential) problematic situations, like no right access to
## files and directories

if [[ ! -z "${DEBUG}" ]]; then
    if [[ ${#PROBLEMS[@]} -gt 0 ]]; then
	debug_configure "\nPotential problems found:\n${PROBLEMS[@]}"
    else
	debug_configure "No potential problems found."
    fi
fi


## if the script is sourced do nothing, otherwise run main flow
if [[ -z "${SOURCED}" ]]; then
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "start main function \`do_configure' ..."

    do_configure

    [[ ! -z ${DEBUG} ]] && \
	debug_configure "... main function \`do_configure' done."
else
    [[ ! -z ${DEBUG} ]] && \
	debug_configure "you may run main function \`do_configure'."
    
fi

### done
