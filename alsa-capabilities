#!/usr/bin/env bash

## This script for linux with bash 4.x displays a list with the audio
## capabilities of each alsa audio output interface and stores them in
## arrays for use in other scripts.  This functionality is exposed by
## the `return_alsa_interface' function which is avaliable after
## sourcing the file. When ran from a shell, it will call that
## function.
##
##  Copyright (C) 2014 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## Source:    https://github.com/ronalde/mpd-configure
## See also:  http://lacocina.nl/detect-alsa-output-capabilities

LANG=C

APP_NAME_AC="alsa-capabilities"
APP_VERSION="0.9.1"

## set DEBUG to a non empty value to display internal program flow to
## stderr
DEBUG="${DEBUG:-}"
## set PROFILE to a non empty value to get detailed timing
## information. Normal output is suppressed.
PROFILE="${PROFILE:-}"
## to see how the script behaves with a certain output of aplay -l
## on a particular host, store it's output in a file and supply
## the file path as the value of TESTFILE, eg:
## `TESTFILE=/tmp/somefile ./bash-capabilities
## All hardware and device tests will fail or produce fake outputs
## (hopefully with some grace).
TESTFILE="${TESTFILE:-}"


### generic functions

function die() {
    printf "\nError in %s (v%s): %s\n" \
	   "${APP_NAME_AC}" "${APP_VERSION}" "$@" 1>&2;
    exit 1
}

function debug() {
    printf "DEBUG %s *** %s\n" \
	   "${APP_NAME_AC}" "$@" 1>&2;
}

function debug_function_ac() {
    printf "DEBUG %-18s:\n" "${APP_NAME_AC}" 1>&2;
    printf "\tentering function \`%s',\n" "$1" 1>&2;
    printf "\twith arguments \`%s'\n" "$2" 1>&2;
}


function command_not_found() {
    ## give installation instructions for package $2 when command $1
    ## is not available, optional with non default instructions $3
    ## and exit with error

    command="$1"
    package="$2"
    instructions="${3:-}"
    msg="command \`${command}' not found. "
    if [[ -z "${instructions}" ]]; then
	msg+="Users of Debian and Ubuntu can install it with:\n"
	msg+=" sudo apt-get install ${package}"
    else
	msg+="${instructions}"
    fi
    die "${msg}"

}


### alsa related functions
function get_aplay_output() {
    ## use aplay to do a basic alsa sanity check and return its (raw)
    ## output to the calling function.
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    res=""
    aplay_msg_nosoundcards_regexp="no[[:space:]]soundcards"
    aplay_card_regexp="${1}"
    if [[ ! -z "${TESTFILE}" ]]; then
	if [[ ! -f "${TESTFILE}" ]]; then
	    printf "${MSG_APLAY_ERROR_NOSUCHTESTFILE}" "${TESTFILE}"
	    return 1
	else
	    ## get the output from a file for testing purposes
	    printf "${MSG_APLAY_USINGTESTFILE}\n" "${TESTFILE}" 1>&2;
	    res="$(< "${TESTFILE}")"
	    if [[ $? -ne 0 ]]; then
		printf "${MSG_APLAY_ERROR_OPENINGTESTFILE}"
		return 1
	    fi
	fi
    else
    	## run aplay to check for alsa errors or display audio cards
	res="$(${CMD_APLAY} -l 2>&1)"
	## check for alsa errors
	if [[ $? -ne 0 ]]; then
	    printf "${MSG_APLAY_ERROR_GENERAL}\n" "${res}"
	    return 1
	fi
	## check for no soundcards
	if [[ "${res}" =~ ${aplay_msg_nosoundcards_regexp} ]]; then
	    printf "%s\n" "${MSG_APLAY_ERROR_NOSOUNDCARDS}"
	    return 1
	fi
    fi
    ## return the result to the calling function
    printf "%s" "${res}"

}

function get_driver() {
    ## TODO: fix
    card_nr="$1"
    card_name="card${card_nr}"
    sysclasssound="/sys/class/sound"
    driver=""

    module=$(readlink /sys/class/sound/${card_name}/device/driver/module || return 1)
    driver="${module##*/}"
    printf "%s" "${driver}"

}

function get_codecs() {
    ## TODO: fix
    card_nr="$1"
    card_name="card${card_nr}"
    driver="$2"
    driverusb="snd_usb_audio"
    codec_re="^Codec:[[:space:]](.*)$"

    if [[ "${driver}" == "${driverusb}" ]]; then
	codecs="N/A"
	printf "%s\n" "${codecs}"
    else
	for codec_file in /proc/asound/${card_name}/codec#*; do
	    while read -r line; do
		if [[ "${line}" =~ ${codec_re} ]]; then
		    printf "%s\n" "${BASH_REMATCH[1]}"
		    break
		fi
	    done<"${codec_file}"
	done
    fi
}

function handle_doublebrackets() {
    ## return the name of the alsa card / device, even when they
    ## contain brackets.

    string="$@"
    [[ ! -z ${DEBUG} ]] && \
	debug "${FUNCNAME} (${LINENO}): using string: \`${string}'"

    bracketcounter=0

    for (( i=0; i<${#string}; i++ )); do
	char="${string:$i:1}"
	#printf "." 1>&2;
	if [[ "${char}" = "[" ]]; then
	    (( bracketcounter++ ))
	elif [[ "${char}" = "]" ]]; then
	    (( bracketcounter-- ))
	fi
	if [[ ${bracketcounter} -gt 0 ]]; then
	    ## inside outer brackets
	    if [[ ${bracketcounter} -lt 2 ]] && [[ "${char}" == "[" ]]; then
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): name with brackets found."
	    else
		printf "${char}"
	    fi
	fi
    done

}

function fetch_alsa_outputinterfaces() {
    ## parses each output interface returned by `get_aplay_output'
    ## after filtering (when the appropriate commandline options are
    ## given), stores its capabilities in the appropriate global
    ## indexed arrays and displays them.

    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    msg=()
    aplay_lines=()
    integer_regexp='^[0-9]+$'
    aplay_card_regexp="^card[[:space:]][0-9]+:"
    aplay_output="$(get_aplay_output "${aplay_card_regexp}")"
    ## exit on error
    [[ $? -eq 0 ]] || die "${aplay_output}"

    ## reset the counter for interfaces without filtering
    NR_AIFS_BEFOREFILTERING=0

    ## modify the filter for aplay -l when OPT_HWFILTER is set
    if [[ ! -z "${OPT_HWFILTER}" ]]; then
	# the portion without `hw:', eg 0,1
	alsa_filtered_hwaddr="${OPT_HWFILTER#hw:*}"
	alsa_filtered_cardnr="${alsa_filtered_hwaddr%%,*}"
	alsa_filtered_devicenr="${alsa_filtered_hwaddr##*,}"
	if [[ ! ${alsa_filtered_cardnr} =~ ${integer_regexp} ]] || \
	       [[ ! ${alsa_filtered_devicenr} =~ ${integer_regexp} ]]; then
	    msg+=("Invalid OPT_HWFILTER (\`${OPT_HWFILTER}') specified.")
	    msg+=("Should be \`hw:x,y' were x and y are both integers.")
	    die "$(printf "%s\n" "${msg[@]}")"
	fi
	aplay_card_regexp="^card[[:space:]]${alsa_filtered_cardnr}:[[:space:]].*"
	aplay_device_regexp="[[:space:]]device[[:space:]]${alsa_filtered_devicenr}:"
	aplay_card_device_regexp="${aplay_card_regexp}${aplay_device_regexp}"
    else
	aplay_card_device_regexp="${aplay_card_regexp}"
    fi

    ## iterate each line of aplay output
    while read -r line ; do
	## filter for `^card' and then for `OPT_FILTER' to get matching
	## lines from aplay and store them in an array

	if [[ "${line}" =~ ${aplay_card_device_regexp} ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug  "${FUNCNAME}: Inspecting interface: ${line}"
	    ## raise the counter for interfaces without filtering
	    let NR_AIFS_BEFOREFILTERING+=1
	    ## check if line matches `OPT_FILTER'
	    if [[ -z "${OPT_FILTER}"  || \
			"$(echo -e "${line}" | grep -E "${OPT_FILTER}")" ]]; then
		[[ ! -z ${DEBUG} ]] && \
		    debug  "${FUNCNAME}:                match: ${line}"
		## store the line in an array
		aplay_lines+=("${line}")
	    fi
	fi
    done <<< "${aplay_output}"

    ## check whether soundcards were found
    if [[ ${#aplay_lines[@]} -lt 1 ]]; then
	die "${#aplay_lines[@]} soundcards found"
    fi

    ## loop through each item in the array
    for line in "${aplay_lines[@]}"; do
	## set if type to default (ie analog)
	alsa_if_type="ao"
	## construct bash regexp for sound device
	## based on aplay.c:
	## printf(_("card %i: %s [%s], device %i: %s [%s]\n"),
	## 1 card,
	## 2 snd_ctl_card_info_get_id(info),
	## 3 snd_ctl_card_info_get_name(info),
	## 4 dev,
	## 5 snd_pcm_info_get_id(pcminfo),
	## 6 snd_pcm_info_get_name(pcminfo));
	##
	## portion (ie before `,')
	alsa_dev_regexp="card[[:space:]]([0-9]+):[[:space:]](.*)[[:space:]]\[(.*)\]"
	## same for interface portion
	alsa_if_regexp=",[[:space:]]device[[:space:]]([0-9]+):[[:space:]](.*)[[:space:]]\[(.*)\]"
	alsa_dev_if_regexp="^${alsa_dev_regexp}${alsa_if_regexp}$"

	## unset / empty out all variables
	alsa_dev_nr=""
	alsa_dev_name=""
	alsa_dev_label=""
	alsa_if_nr=""
	alsa_if_name=""
	alsa_if_label=""

	## start matching and collect errors in array
	errors=()

	## see if the name contains square brackets, ie it ends with `]]'
	name=""
	alsacard=""
	seperator_start="*##"
	seperator_end="##*"
	name_re="card[[:space:]][0-9]+:[[:space:]](.*)\[.*\[.*\]\].*"
	brackets_re="card[[:space:]]([0-9]+):(.*\])\],[[:space:]](device[[:space:]][0-9]+:.*\])"
	if [[ "${line}" =~ ${brackets_re} ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): #####: line with brackets \`${line}'"
	    if [[ "${line}" =~ ${name_re} ]]; then
		name="${BASH_REMATCH[1]}"
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): #####: name \`${name}'"
	    fi
	fi
	if [[ ! -z "${name}" ]]; then
	    if [[ "${line}" =~ ${brackets_re} ]]; then
		## construct string without brackets
		alsacard="$(handle_doublebrackets "${BASH_REMATCH[2]}")"
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): #####: alsacard: \`${alsacard}'"

		## replace `name [something]' with `name *##something##*'
		alsacard="${alsacard//\[/${seperator_start}}"
		alsacard="${alsacard//\]/${seperator_end}}"
		line="card ${BASH_REMATCH[1]}: ${name}[${alsacard}], ${BASH_REMATCH[3]}"
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): #####: replace line with \`${line}'"
	    fi
	fi

	## match the current line with the regexp
	if [[ "${line}" =~ ${alsa_dev_if_regexp} ]]; then
	    [[ ! -z "${BASH_REMATCH[1]}" ]] && \
		alsa_dev_nr="${BASH_REMATCH[1]}" || \
		    errors+=("could not fetch device number")
	    if [[ ! -z "${BASH_REMATCH[2]}" ]]; then
		alsa_dev_name="${BASH_REMATCH[2]}"
		## reconstruct original name if it contained square brackets
		alsa_dev_name="${alsa_dev_name//${seperator_start}/\[}"
		alsa_dev_name="${alsa_dev_name//${seperator_end}/\]}"
	    else
		errors+=("could not fetch device name")
	    fi
	    [[ ! -z "${BASH_REMATCH[3]}" ]] && \
		alsa_dev_label="${BASH_REMATCH[3]}" || \
		    errors+=("could not fetch device label")
	    [[ ! -z "${BASH_REMATCH[4]}" ]] && \
		alsa_if_nr="${BASH_REMATCH[4]}" || \
		    errors+=("could not fetch interface number")
	    [[ ! -z "${BASH_REMATCH[5]}" ]] && \
		alsa_if_name="${BASH_REMATCH[5]}" || \
		    errors+=("could not fetch interface name")
	    [[ ! -z "${BASH_REMATCH[6]}" ]] && \
		alsa_if_label="${BASH_REMATCH[6]}" || \
		    errors+=("could not fetch interface label")
	    ## consider empty numbers and names of devices and interfaces fatal
	    if [[ -z ${alsa_dev_nr} ]] || \
		   [[ -z ${alsa_dev_name} ]] || \
		   [[ -z ${alsa_if_nr} ]] || \
		   [[ -z ${alsa_if_name} ]]; then
		die "$(prinf "%s\n" "${errors[@]}")"
		break
	    fi

	    if [[ ! -z ${DEBUG} ]] && [[ "${#errors[@]}" -ne 0 ]]; then
		debug "${FUNCNAME} (${LINENO}): $(printf "errors: %s\n" "${errors[@]}")"
	    fi

	    declare -a alsa_if_formats=()
	    alsa_if_hwaddress="hw:${alsa_dev_nr},${alsa_if_nr}"
	    ## construct the path to the character device for the
	    ## interface (ie `/dev/snd/xxx')
	    alsa_if_chardev="/dev/snd/pcmC${alsa_dev_nr}D${alsa_if_nr}p"
	    ## construct the path to the hwparams file
	    alsa_if_hwparamsfile="/proc/asound/card${alsa_dev_nr}/pcm${alsa_if_nr}p/sub0/hw_params"
	    alsa_if_statusfile="/proc/asound/card${alsa_dev_nr}/pcm${alsa_if_nr}p/sub0/status"
	    ## before determining whether this is a usb device, assume
	    ## the monitor file is the hwparams file
	    alsa_if_monitorfile="${alsa_if_hwparamsfile}"
	    ## assume stream file for the interface (ie
	    ## `/proc/asound/cardX/streamY') to determine whether
	    ## the interface is a uac device, and if so, which class it is
	    alsa_if_streamfile="/proc/asound/card${alsa_dev_nr}/stream${alsa_if_nr}"
	    ## keep track of status of interface
	    alsa_if_closed=0
	    ## assume no uac device
	    alsa_if_uacclass="${MSG_PROP_NOTAVAILABLE}"

	    if [[ ! -z ${TESTFILE} ]]; then
		## device is not real
		alsa_if_formats+=("(${MSG_ERROR_CHARDEV_NOFORMATS})")
		alsa_if_uacclass_nr="?"
		alsa_if_uacclass_label="${MSG_PROP_NOTAVAILABLE}"
	    else
		## check if the hwparams file exists
		if [[ ! -f "${alsa_if_hwparamsfile}" ]]; then
		    alsa_if_hwparamsfile="${alsa_if_hwparamsfile} (error: not accessible)"
		fi
		## check if the chardev exists
		if [[ ! -c "${alsa_if_chardev}" ]]; then
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): alsa_if_chardev \`${alsa_if_chardev}' is not a chardev."
		    alsa_if_chardev="${alsa_if_chardev} (${MSG_ERROR_NOT_CHARDEV})"
		else
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): alsa_if_chardev \`${alsa_if_chardev}' is a valid chardev."
		fi
		## check whether the monitor file exists; it always should
		if [[ ! -f ${alsa_if_monitorfile} ]]; then
		    msg="${alsa_if_monitorfile} ${MSG_ERROR_NOFILE} (${MSG_ERROR_UNEXPECTED})"
		    alsa_if_monitorfile="${msg}"
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): ${MSG_ERROR_UNEXPECTED}: alsa_if_monitorfile \
\`${alsa_if_monitorfile}' ${MSG_ERROR_NOFILE}"
		fi
		## check whether the streamfile exists; it only should
		## exist in the case of a uac interface
		if [[ ! -f "${alsa_if_streamfile}" ]]; then
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): alsa_if_streamfile \`${alsa_if_streamfile}' \
${MSG_ERROR_NOFILE}"
		    ## no uac interface
		    alsa_if_streamfile=""
		else
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): using alsa_if_streamfile \`${alsa_if_streamfile}'."
		    ## set interface to usb out
		    alsa_if_type="uo"
		    ## uac devices will use the stream file instead of
		    ## hwparams file to monitor
		    alsa_if_monitorfile="${alsa_if_streamfile}"
		    ## get the type of uac endpoint
		    alsa_if_uac_ep="$(return_alsa_uac_ep "${alsa_if_streamfile}")"
		    if [[ $? -ne 0 ]]; then
			alsa_if_uacclass_nr="?"
			alsa_if_uacclass_label="${MSG_PROP_NOTAVAILABLE}"
		    else
			[[ ! -z ${DEBUG} ]] && \
			    debug "${FUNCNAME} (${LINENO}): alsa_if_uac_ep set to \`${alsa_if_uac_ep}'."
			## lookup the uac class in the array for this type of endpoint (EP)
			## (for readability)
			alsa_if_uacclass="${UO_EP_LABELS[${alsa_if_uac_ep}]}"
			## the uac class number (0, 1, 2 or 3) according to ./sound/usb/card.h
			alsa_if_uacclass_nr="${alsa_if_uacclass% - *}"
			classnr_regexp='^[0-3]+$'
			if [[ ! ${alsa_if_uacclass_nr} =~ ${classnr_regexp} ]]; then
			    [[ ! -z ${DEBUG} ]] && \
				debug "${FUNCNAME} (${LINENO}): invalid uac class number \`${alsa_if_uacclass_nr}'. \
${MSG_ERROR_UNEXPECTED}"
			    alsa_if_uacclass_nr="?"
			fi
			## the uac label (ie everything after `x: ')
			alsa_if_uacclass_label="${alsa_if_uacclass:4}"
		    fi

		fi
	    fi
	fi

	## for non-uac interfaces: check whether it is some other digital interface
	if [[ ! "${alsa_if_type}" = "uo" ]]; then
	    for filter in "${DO_INTERFACE_FILTER[@]}"; do
		## `,,' downcases the string, while `*var*' does a wildcard match
		if [[ "${alsa_if_name,,}" == *"${filter}"* ]]; then
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): match = ${alsa_if_name,,}: ${filter}"
		    ## set ao type to d(igital)o(out)
		    alsa_if_type="do"
		    ## exit this for loop
		    break
		fi
	    done
	fi
	## see if the interface type matches the user specified
	## filters and if so construct titles and store a pair of
	## hardware address and monitoring file in the proper array
	match=
	case "${alsa_if_type}" in
	    "ao")
		## only if neither `OPT_LIMIT_DO' and `OPT_LIMIT_UO' are set
		[[ ! -z ${OPT_LIMIT_DO} || ! -z ${OPT_LIMIT_UO} ]] && \
		    continue || match="true"
		;;
	    "do")
		## only if neither `OPT_LIMIT_AO' and `OPT_LIMIT_UO' are set
		[[ ! -z ${OPT_LIMIT_AO} || ! -z ${OPT_LIMIT_UO} ]] && \
		    continue || match="true"
		;;
	    "uo")
		## only if `OPT_LIMIT_AO' is not set
		[[ ! -z ${OPT_LIMIT_AO} ]] && \
		    continue || match="true"
	esac
	if [[ ! -z ${match} ]]; then
	    ## put each encoding format and possibily the sample rates
	    ## in an array
	    alsa_if_formats=()
	    formats_res_err=
	    formats_res="$(return_alsa_formats \
"${alsa_dev_nr}" \
"${alsa_if_nr}" \
"${alsa_if_type}" \
"${alsa_if_streamfile}" \
"${alsa_if_chardev}")"
	    if [[ $? -ne 0 ]]; then
		formats_res_err=1
	    fi
	    alsa_if_formats+=("${formats_res[@]}")
	    alsa_if_title_label="${ALSA_IF_LABELS[${alsa_if_type}]}"
	    ## reconstruct the label if it contained square brackets
	    if [[ "${alsa_dev_label}" =~ .*${seperator_start}.* ]]; then
		alsa_dev_label="${alsa_dev_label//\*##/\[}"
		alsa_dev_label="${alsa_dev_label//##\*/\]}"
	    fi
	    ## construct the display title
	    alsa_if_display_title=$(printf " %s) %s \`%s'" \
					   "${#ALSA_AIF_HWADDRESSES[@]}" \
					   "${alsa_if_title_label}" \
					   "${alsa_if_hwaddress}")
	    ## store the details of the current interface in global arrays
	    ALSA_AIF_HWADDRESSES+=("${alsa_if_hwaddress}")
	    ALSA_AIF_MONITORFILES+=("${alsa_if_monitorfile}")
	    ALSA_AIF_DISPLAYTITLES+=("${alsa_if_display_title}")
	    ALSA_AIF_DEVLABELS+=("${alsa_dev_label}")
	    ALSA_AIF_LABELS+=("${alsa_if_label}")
	    ALSA_AIF_UACCLASSES+=("${alsa_if_uacclass}")
	    ALSA_AIF_FORMATS="${alsa_if_formats[@]}"
	    ALSA_AIF_CHARDEVS+=("${alsa_if_chardev}")
	fi

	if [[ -z "${OPT_QUIET}" ]]; then
	    ## print the list to std_err
	    printf "%s\n" "${alsa_if_display_title}" 1>&2;
	    printf " - %-17s = %-60s\n" \
		   "${MSG_ALSA_DEVNAME}" "${alsa_dev_label}" 1>&2;
	    printf " - %-17s = %-60s\n" \
		   "${MSG_ALSA_IFNAME}" "${alsa_if_label}" 1>&2;
	    printf " - %-17s = %-60s\n" \
		   "${MSG_ALSA_UACCLASS}" "${alsa_if_uacclass}" 1>&2;
	    printf " - %-17s = %-60s\n" \
		   "${MSG_ALSA_CHARDEV}" "${alsa_if_chardev}" 1>&2;
	    if [[ ! -z ${formats_res_err} ]]; then
		## device is locked by an unspecified process
		printf " - %-17s = %-60s\n" \
		       "${MSG_ALSA_ENCODINGFORMATS}" \
		       "${MSG_ERROR_GETTINGFORMATS}"  1>&2;
		printf "   %-17s   %-60s\n" \
		       " " \
		       "${formats_res[@]}"  1>&2;
	    else
		formatcounter=0
		MSG_ALSA_ENCODINGFORMATS="rates per format"
		printf " - %-17s = " \
		       "${MSG_ALSA_ENCODINGFORMATS}" 1>&2;
		while IFS="\n" read -r line; do
		    (( formatcounter++ ))
		    if [[ ${formatcounter} -gt 1 ]]; then
			printf "%-23s" " " 1>&2;
		    fi
		    printf "%-60s\n" "${line}" 1>&2;
		done<<<"${alsa_if_formats[@]}"
	    fi
	    printf " - %-17s = %-60s\n" \
		   "${MSG_ALSA_MONITORFILE}" "${alsa_if_monitorfile}" 1>&2;
	    printf "\n"
	fi
    done
}

function get_locking_process() {
    ## return a string describing the parent command and PID of the
    ## process locking the audio interface with card nr $1 and dev nr
    ## $2 as indicated by its status file in /proc/asound. Only called
    ## when there's an indication the device is actually locked.
    ## returns an error status when its unable to find the parent process.
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    alsa_card_nr="$1"
    alsa_if_nr="$2"
    proc_statusfile="/proc/asound/card${alsa_card_nr}/pcm${alsa_if_nr}p/sub0/status"
    owner_pid=
    parent_pid=
    parent_cmd=

    ## locking process indicated by `owner_pid` in /proc/asound/cardX/pcmYp/sub0/status
    ## example `owner_pid   : 28022' is a child of the mpd parent process:
    ##mpd(28017,mpd)-+-{decoder:flac}(28021)
    ##               |-{io}(28019)
    ##               |-{output:Peachtre}(28022)
    ##               `-{player}(28020)
    owner_pid_re="owner_pid[[:space:]]+:[[:space:]]+([0-9]+)"
    while read -r line; do
	if [[ "${line}" =~ ${owner_pid_re} ]]; then
	    owner_pid="${BASH_REMATCH[1]}"
	    break
	fi
    done<"${proc_statusfile}"
    if [[ -z ${owner_pid} ]]; then
	## strange, device seems unused
	## TODO: handle situation
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME} (${LINENO}): ${FUNCNAME} called, but no owner_pid found in \`${proc_statusfile}'."
	return 1
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME} (${LINENO}): found owner pid: \`${owner_pid}'."
    fi
    ## look up parent process of locking process
    ## `ps -q ${PID} -ejf` produces
    ## UID        PID  PPID  PGID   SID  C STIME TTY          TIME CMD
    ## mpd      28017     1 28017 28017 15 08:39 ?        00:10:36 /usr/bin/mpd --no-daemon
    ## set arguments for ps command
    psopts=(-q ${owner_pid})
    ## we (possibly?) need the parent for the locking process, so both
    ## e and f are needed
    psopts+=(-ejf)
    ## create an array for each output line of ps
    ## double parenthesis are needed for proper array initialization
    declare -a "ps_out_raw=($(${CMD_PS} "${psopts[@]}"))"
    if [[ $? -ne 0 ]]; then
	## should not happen
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME} (${LINENO}): owner_pid \`${owner_pid}' has no parent_pid."
	return 1
    else
	## ps returned header line and at least one extra line, each
	## with 10 values
	## TODO: bit flaky?
	if [[ ${#ps_out_raw[@]} -lt 20 ]]; then
	    ## should not happen
	    if [[ ! -z ${DEBUG} ]]; then
		debug "${FUNCNAME} (${LINENO}): ps returned no error but neither a value for owner_pid \`${owner_pid}'."
		debug "${FUNCNAME} (${LINENO}): ps_out_raw contains ${#ps_out_raw[@]} items: \`${ps_out_raw[@]}' "
	    fi
	    return 1
	else
	    ## get the array items (fields) containing the ppid and pcmd
	    parent_pid="${ps_out_raw[-10]}"
	    parent_cmd="${ps_out_raw[-2]}"
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): \`${owner_pid}' has parent_pid \`${parent_pid}', parent_cmd \`${parent_cmd}'."
	    ## return comma seperated list (pid,cmd) to calling function
	    printf "%s,%s" "${parent_pid}" "${parent_cmd}"
	fi
    fi

}

function return_alsa_samplerates() {
    ## use aplay to get supported sample rates for playback for
    ## specified non-uac interface ($1) and encoding format ($2)
    ## between minimum ($3) and maximum ($4) supported rates. returns
    ## space seperated list of valid rates.
    ## TODO: document
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    alsa_if_hwaddress="$1"
    format="$2"
    hw=""

    ## sanity checks
    if [[ -z "${rawformats[0]}" ]]; then
	## something went wrong
	return 1
    fi

    [[ ! -z ${DEBUG} ]] && \
	debug "${FUNCNAME} (${LINENO}): getting sample rates for device \`${alsa_if_hwaddress}' \
using format \`${format}'."

    errors=()
    noerror=
    ## assume fs*1 is always supported to save time
    printf "%s\n" "${SAMPLERATES_AUDIO[0]}"
    for rate in ${SAMPLERATES_AUDIO[@]:1}; do
	res="$(check_samplerate "${alsa_if_hwaddress}" "${format}" "${rate}")"
	if [[ $? -eq 0 ]]; then
	    printf "%s\n" "${res}"
	else
	    break
	fi
    done

    ## assume fs*1 is always supported to save time
    printf "%s\n" "${SAMPLERATES_VIDEO[1]}"
    for rate in ${SAMPLERATES_VIDEO[0]} ${SAMPLERATES_VIDEO[@]:2} ${SAMPLERATES_VIDEO[@]:2}; do
	res="$(check_samplerate "${alsa_if_hwaddress}" "${format}" "${rate}")"
	if [[ $? -eq 0 ]]; then
	    printf "%s\n" "${res}"
	else
	    break
	fi
    done

}

function check_samplerate() {

    alsa_if_hwaddress="$1"
    format="$2"
    samplerate="$3"

    declare -a aplay_opts_pre
    aplay_opts_pre+=(--device="${alsa_if_hwaddress}")
    aplay_opts_pre+=(--format="${format}")
    aplay_opts_pre+=(--channels="2")
    aplay_opts_pre+=(--nonblock)
    declare -a aplay_opts_post
    rate_notaccurate_re=".*Warning:.*not[[:space:]]accurate[[:space:]]\(requested[[:space:]]=[[:space:]]([0-9]+)Hz,[[:space:]]got[[:space:]]=[[:space:]]([0-9]+)Hz\).*"
    badspeed_re=".*bad[[:space:]]speed[[:space:]]value.*"
    sampleformat_nonavailable_re=".*Sample[[:space:]]format[[:space:]]non[[:space:]]available.*"
    wrongformat_re=".*wrong[[:space:]]extended[[:space:]]format.*"
    default_re=".*Playing[[:space:]]raw[[:space:]]data.*"

    [[ ! -z ${DEBUG} ]] && debug "${FUNCNAME} (${LINENO}): testing rate ${samplerate}"
    unset aplay_opts_post
    aplay_opts_post+=(--rate="${samplerate}")
    aplay_out=$(echo "${PSEUDO_RANDOM_NOISE}" | \
		       LANG=C ${CMD_APLAY} "${aplay_opts_pre[@]}" "${aplay_opts_post[@]}" 2>&1)
    if [[ $? -eq 0 ]]; then
	read -r firstline<<<"${aplay_out}"
	if [[ "${aplay_out}" = "${firstline}" ]] && \
	       [[ "${firstline}" =~ ${default_re} ]]; then
	    [[ ! -z ${DEBUG} ]] && debug "${FUNCNAME} (${LINENO}): success"
	    printf "%s" "${samplerate}"
	else
	    [[ ! -z ${DEBUG} ]] && debug "${FUNCNAME} (${LINENO}): failure"
	    break
	fi
    else
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME} (${LINENO}): aplay returned an error using \
format ${format} @ rate ${samplerate}: \`${aplay_out}'"
    fi

}


function check_alsa_device_unlocked() {
    ## check if the interface (hw:$1,$2) is locked by another process
    ## return true if unlocked with aplay output, 1 when locked with ppid,pcmd
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    alsa_dev_nr="$1"
    alsa_if_nr="$2"

    aplay_opts=(--device=hw:${alsa_dev_nr},${alsa_if_nr})
    aplay_opts+=(--channels=2)
    aplay_opts+=(--format=MPEG)
    aplay_opts+=(--nonblock)
    #aplay_opts+=(--dump-hw-params)
    declare -a rawformats
    device_busy_re=".*aplay.*main.*audio.*error(.*)"
    device_busy_error=0
    aplay_out="$(echo ${PSEUDO_RANDOM_NOISE} | \
LANG=C ${CMD_APLAY} "${aplay_opts[@]}" 2>&1 >/dev/null)"
    while read -r line; do
	if [[ "${line}" =~ ${device_busy_re} ]]; then
	    device_busy_error=1
	    break
	fi
    done <<< "${aplay_out}"

    if [[ ${device_busy_error} -eq 1 ]]; then
	res="$(get_locking_process "${alsa_dev_nr}" "${alsa_if_nr}")"
	## return the parent_pid,parent_cmd with error
	printf "%s" "${res}"
	return 1
    else
	## return aplay_out
	printf "%s" "${aplay_out}"
    fi

}

function return_alsa_formats() {
    ## fetch and return a comma separated string of playback formats
    ## for the interface specified in $1, of type $2. For non-uac
    ## interfaces: feed dummy input to aplay (--format=MPEG). For uac
    ## types: filter it directly from its stream file $3.
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    alsa_dev_nr="$1"
    alsa_if_nr="$2"
    alsa_if_type="$3"
    alsa_if_streamfile="$4"
    alsa_if_chardev="$5"
    format="${format:-}"
    rawformat="${rawformat:-}"
    formats=()
    parent_pid=
    parent_cmd=
    locking_error=

    if [[ "${alsa_if_type}" = "uo" ]]; then
	declare -A uac_formats
	interface_re="^[[:space:]]*Interface[[:space:]]([0-9])"
	format_re="^[[:space:]]*Format:[[:space:]](.*)"
	rates_re="^[[:space:]]*Rates:[[:space:]](.*)"
	capture_re="^Capture:"
	inside_interface=
	format_found=
	while read -r line; do
	    ## iterate the streamfile
	    if [[ "${line}" =~ ${capture_re} ]]; then
		## end of playback interfaces
		break
	    else
		if [[ "${line}" =~ ${interface_re} ]]; then
		    ## new interface found
		    inside_interface=true
		    ## reset (previous) format_found
		    format_found=
		else
		    if [[ ! -z ${inside_interface} ]]; then
			## parse lines below `Interface:`
			if [[ ! -z "${format_found}" ]]; then
			    ## parse lines below `Format:`
			    if [[ "${line}" =~ ${rates_re} ]]; then
				## sample rates for interface/format found;
				## add to array and reset both
				uac_formats[${format_found}]+="${BASH_REMATCH[1]//,/} "
				[[ ! -z ${DEBUG} ]] && \
				    debug "array: key=${format_found}, \
rate=${uac_formats[${format_found}]} "
				format_found=
				inside_interface=
				continue

			    fi
			else
			    ## check for new `Format:`
			    if [[ "${line}" =~ ${format_re} ]]; then
				## new format found
				format_found="${BASH_REMATCH[1]}"
				formats+=(${format_found})
				[[ ! -z ${DEBUG} ]] && \
				    debug "${FUNCNAME} (${LINENO}): format found: \`${format_found}'"
				## next: sample rates or new interface
			    fi

			fi
		    fi
		fi
	    fi
	done<"${alsa_if_streamfile}"

	## return the formatted line(s)
	if [[ ! -z ${OPT_SAMPLERATES} ]]; then
	    ## for each format, print "FORMAT: rate1Hz rate2Hz ..."
	    for key in ${!uac_formats[@]}; do
	 	printf "%-20s %s\n" "${key}:" "${uac_formats[${key}]// /Hz }"
	    done
	else
	    ## print comma seperated list of formats
	    formats="$(printf "%s, " ${!uac_formats[@]})"
	    printf "%-20s" "${formats%*, }"
	fi

    else
	## non-uac type: if interface is not locked, use aplay to determine formats
	declare -a rawformats
	## because of invalid file format, aplay is forced to return
	## supported formats (=200 times faster than --dump-hw-params)
	format_re="^-[[:space:]]+([[:alnum:]_]*)$"
	#format_re="^FORMAT:[[:space:]]*(.*)"
	#rate_re="^RATE:[[:space:]]+\[([0-9]+)[[:space:]]([0-9]+)\]"
	aplay_out="$(check_alsa_device_unlocked "${alsa_dev_nr}" "${alsa_if_nr}")"

	if [[ $? -ne 0 ]]; then
	    ## $aplay_out contains pid,cmd of locking process
	    locking_error=True
	    parent_pid="${aplay_out%,*}"
	    parent_cmd="${aplay_out#*,}"
	    ## check if pulseaudio is locking the interface
	    CMD_PULSEAUDIO="$(which pulseaudio 2>/dev/null)"
	    if [[ "${parent_cmd}" == "${CMD_PULSEAUDIO}" ]]; then
		## pulseaudio is locking the interface, try to stop it
		source ${PA_HELPER_SCRIPT}
		locking_error="$(paclient_stop "${parent_pid}")"
		if [[ $? -ne 0 ]]; then
		    ## received an error; could not stop pulseaudio
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): unable to stop pulseaudio: ${locking_error}"
		    ## return the error instead of the formats
		    locking_error=True
		else
		    ## really?
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): stop pulseaudio returned succes: check again"
		    aplay_out="$(check_alsa_device_unlocked "${alsa_dev_nr}" "${alsa_if_nr}")"
		    if [[ $? -ne 0 ]]; then
			[[ ! -z ${DEBUG} ]] && \
			    debug "${FUNCNAME} (${LINENO}): second attempt failed: \
pulseaudio still running with PID ${parent_pid}"
			## $aplay_out contains pid,cmd of locking process
			locking_error=True
			parent_pid="${aplay_out%,*}"
			parent_cmd="${aplay_out#*,}"
		    else
			[[ ! -z ${DEBUG} ]] && \
			    debug "${FUNCNAME} (${LINENO}): second attempt succeeded; device no longer locked."
			## empty out locking_error
			locking_error=
		    fi
		fi
	    else
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): device is in use by ${parent_cmd} with PID ${parent_pid}."
		## in use by another process
		##  return the error instead of the formats
		locking_error=True
		printf "%s" "${msg}"
	    fi
	fi

	if [[ ! -z "${locking_error}" ]]; then
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): device is still locked by \
${parent_cmd} with PID ${parent_pid}; bailing out"
	    printf "by command %s with PID %s" "${parent_cmd}" "${parent_pid}"
	    return 1
	else
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): device is not locked; will iterate aplay_out"
	    ## device is not locked, iterate aplay output
	    while read -r line; do
		if [[ "${line}" =~ ${format_re} ]]; then
		    rawformats+=(${BASH_REMATCH[1]})
		fi
	    done <<< "${aplay_out}"

 	    ## aplay returned no locking error
	    ## formats (and minimum/maximum sample rates gathered, check if
	    ## all sample rates should be checked

	    ## warning: slowness ahead
	    declare -a sorted_rates
	    rates_supported=("$(return_alsa_samplerates \
"${alsa_if_hwaddress}" "${rawformats[0]}")")
	    if [[ $? -ne 0 ]]; then
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): return_alsa_samplerates returned \`${rates_supported[@]}'"
		return 1
	    fi
	    ## sort the items
	    rates=$(printf "%sHz\n" ${rates_supported[@]} |sort -u -n)
	    sorted_rates=$(printf "%s " ${rates})
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): #### sorted_rates returned: \
$(printf "%s " "${sorted_rates[@]}")"
	    for rawformat in ${rawformats[@]}; do
		printf "%-20s" "${rawformat}: "
		printf "%s" "${sorted_rates[@]}"
		printf "\n"
	    done

	fi
    fi

}


function return_alsa_uac_ep() {
    ## returns/echoes the usb audio class endpoint as a fixed number.
    ## needs path to stream file as single argument ($1)
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    ## based on ./sound/usb/proc.c:
    ##  printf "    Endpoint: %d %s (%s)\n",
    ##   1: fp->endpoint & USB_ENDPOINT_NUMBER_MASK (0x0f) > [0-9]
    ## TODO: unsure which range this is; have seen 1, 3 and 5
    ##   2: USB_DIR_IN: "IN|OUT",
    ##   3: USB_ENDPOINT_SYNCTYPE: "NONE|ASYNC|ADAPTIVE|SYNC"

    alsa_if_streamfile_path="$1"
    ep_mode=""
    ep_label_filter="Endpoint:"
    ep_label_regexp="^[[:space:]]*${ep_label_filter}"
    ep_num_filter="([0-9]+)"                         #1
    ep_num_regexp="[[:space:]]${ep_num_filter}"
    ep_direction_filter="OUT"
    ep_direction_regexp="[[:space:]]${ep_direction_filter}"
    ep_synctype_filter="(${UO_EP_NONE_FILTER}|${UO_EP_ADAPT_FILTER}|${UO_EP_ASYNC_FILTER}|${UO_EP_SYNC_FILTER})"                                   #2
    ep_synctype_regexp="[[:space:]]\(${ep_synctype_filter}\)$"
    ep_regexp="${ep_label_regexp}${ep_num_regexp}${ep_direction_regexp}${ep_synctype_regexp}"

    ## iterate the contents of the streamfile
    while read -r line; do
	if [[ "${line}" =~ ${ep_regexp} ]]; then
	    ep_mode="${BASH_REMATCH[2]}"
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): matching endpoint found in line \`${line}': \`${ep_mode}'."
	    break
	fi
    done<"${alsa_if_streamfile_path}"

    if [[ -z "${ep_mode}" ]]; then
	[[ ! -z ${DEBUG} ]] && \
	    debug "${FUNCNAME} (${LINENO}): no matching endpoints found. ${MSG_ERROR_UNEXPECTED}"
	printf ""
	return 1
    else
	## return the filtered endpoint type
	printf "%s" "${ep_mode}"
    fi

}


### command line parsing

function analyze_opt_limit() {
    ## check if the argument for the `-l' (limit) option is proper
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    option="$1"
    opt_limit="${2-}"
    declare -a args
    prev_opt=0
    prev_arg=0
    argsval=
    case ${opt_limit} in
        a|analog)
	    OPT_LIMIT_AO="True"
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): OPT_LIMIT_AO set to \`${OPT_LIMIT_AO}'"
	    return 0
	    ;;
        u|usb|uac)
	    OPT_LIMIT_UO="True"
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): OPT_LIMIT_UO set to \`${OPT_LIMIT_UO}'"
	    return 0
	    ;;
        d|digital)
	    OPT_LIMIT_DO="True"
	    [[ ! -z ${DEBUG} ]] && \
		debug "${FUNCNAME} (${LINENO}): OPT_LIMIT_DO set to \`${OPT_LIMIT_DO}'"
	    return 0
	    ;;
	*)
	    ## construct list of option pairs: "x (or 'long option')"
	    for arg_index in ${!OPT_LIMIT_ARGS[@]}; do
		if [[ $(( arg_index % 2 )) -eq 0 ]]; then
		    ## even (short option): new array item
		    args+=("")
		else
		    ## odd (long option): add value to previous array item
		    prev_opt=$(( arg_index - 1 ))
		    args[-1]="${OPT_LIMIT_ARGS[${prev_opt}]} (or '${OPT_LIMIT_ARGS[${arg_index}]}')"
		fi
	    done
	    args_val=$(printf "%s, " "${args[@]}")
	    msg_vals="$(printf " ${args_val%*, }\n")"
	    msg_custom="maybe you could try to use the custom filter option, eg:"
	    msg_trail="for limit option \`${option}' specified. should be one of:\n"
	    if [[ ! -z ${opt_limit} ]]; then
		str_re=""
		for (( i=0; i<${#opt_limit}; i++ )); do
		    char="${opt_limit:$i:1}"
		    str_re+="[${char^^}${char,,}]"
		done
		msg="invalid value \`${opt_limit}' "
		msg+="$(printf "${msg_trail}${msg_vals}\n${msg_custom}")"
		## display instructions to use the custom filter
		msg+="$(printf "\n bash $0 -c \"%s\"\n" "${str_re}")"
	    else
		msg="$(printf "no value for ${msg_trail}${msg_vals}")"
	    fi

	    ## display the option pairs, stripping the trailing comma
	    printf "%s\n" "${msg}" 1>&2;
	    exit 1
    esac
}


function display_usageinfo() {
    ## display syntax and exit
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    msg=$(cat <<EOF
Usage:
$0 [ -l a|d|u ]  [ -c <filter> ] [-a <hwaddress>] [-s] [ -q ]

Displays a list of each alsa audio output interface with its details
including its alsa hardware address (\`hw:x,y').

The list may be filtered by using the limit option \`-l' with an
argument to only show interfaces that fit the limit. In addition, a
custom filter may be specified as an argument for the \`c' option.

The \`-q (quiet)' and \`-a (address)' options are meant for usage in
other scripts. The script returns 0 on success or 1 in case of no
matches or other errors.

  -l TYPEFILTER, --limit TYPEFILTER
                     Limit the interfaces to TYPEFILTER. Can be one of
                     \`a' (or \`analog'), \`d' (or \`digital'), \`u'
                     (or \`usb'), the latter for USB Audio Class (UAC1
                     or UAC2) devices.
  -c REGEXP, --customlimit REGEXP
                     Limit the available interfaces further to match
                     \`REGEXP'.
  -a HWADDRESS, --address HWADDRESS
                     Limit the returned interface further to the one
                     specified with HWADDRESS, eg. \`hw:0,1'
  -s, --samplerates  Adds a listing of the supported sample rates for
                     each format an interface supports.
                     CAUTION: Besides being slow this option
                              PLAYS NOISE ON EACH OUTPUT!
  -q, --quiet        Surpress listing each interface with its details,
                     ie. only store the details of each card in the
                     appropriate arrays.
  -h, --help         Show this help message
EOF
       )
    printf "%s\n" "${msg}" 1>&2;
}


function analyze_command_line() {
    ## parse command line arguments using the `manual loop` method
    ## described in http://mywiki.wooledge.org/BashFAQ/035.
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    while :; do
        case "${1:-}" in
            -l|--limit)
		if [ -n "${2:-}" ]; then
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): $(printf "option \`%s' set to \`%s'.\n" "$1" "$2")"
		    OPT_LIMIT="True"
		    analyze_opt_limit "$1" "$2"
		    shift 2
                    continue
		else
		    analyze_opt_limit "$1"
                    exit 1
		fi
		;;
	    -c|--customfilter)
		if [ -n "${2:-}" ]; then
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): $(printf "option \`%s' set to \`%s'.\n" "$1" "$2")"
		    OPT_FILTER="${2}"
		    shift 2
                    continue
		else
                    printf "ERROR: option \`%s' requires a non-empty argument.\n" "$1" 1>&2
                    exit 1
		fi
		;;
            -a|--address)
		if [ -n "${2:-}" ]; then
		    [[ ! -z ${DEBUG} ]] && \
			debug "${FUNCNAME} (${LINENO}): option \`$1' set to \`$2'"
		    OPT_HWFILTER="$2"
		    shift 2
                    continue
		else
                    printf "ERROR: option \`%s' requires a alsa hardware address \
as an argument (eg \`hw:x,y')\n" "$1" 1>&2
                    exit 1
		fi
		;;
            -s|--samplerates)
		## deprecated
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): option \`$1' set"
		OPT_SAMPLERATES=true
		shift
                continue
		;;
	    -q|--quiet|--silent)
		[[ ! -z ${DEBUG} ]] && \
		    debug "${FUNCNAME} (${LINENO}): option \`$1' set"
		OPT_QUIET=true
		shift
                continue
		;;
	    -h|-\?|--help)
		display_usageinfo
		exit
		;;
            --)
		shift
		break
		;;
	    -?*)
		printf "Notice: unknown option \`%s' ignored\n\n." "$1" 1>&2
		display_usageinfo
		exit
		;;
            *)
		break
        esac
    done

}


function return_alsa_interface() {
    ## main function; see display_usageinfo()
    [[ ! -z ${DEBUG} ]] && \
	debug_function_ac "${FUNCNAME}" "$*"

    profile_file=
    paerr=
    ## start profiling
    if [[ ! -z ${PROFILE} ]]; then
	profile_file="/tmp/alsa-capabilities.$$.log"
	PS4='+ $(date "+%s.%N")\011 '
	exec 3>&2 2>${profile_file}
	set -x
    fi

    ## check if needed commands are available
    CMD_APLAY=$(which aplay || command_not_found "aplay" "alsa-utils")
    if [[ $? -ne 0 ]]; then
	die "The script cannot continue without aplay."
    fi
    CMD_PS=$(which ps || command_not_found "ps" "procps")

    ## parse command line arguments
    analyze_command_line "$@"

    ## create a list of alsa audio output interfaces and parse it.
    fetch_alsa_outputinterfaces

    ## exit with error if no matching output line was found
    if [[ ${#ALSA_AIF_HWADDRESSES[@]} == 0 ]]; then
	msg="\n${MSG_MATCH_IF_NONE_UNLIMITED}"
	##  display information about the number of interfaces before filtering
	[[ ! ${NR_AIFS_BEFOREFILTERING} == 0 ]] && \
	    msg=$(printf "${MSG_MATCH_IF_NONE_LIMITED}" \
			 "${NR_AIFS_BEFOREFILTERING}")
	printf "%s\n" "${msg}" 1>&2;
    fi

    [[ ! -z ${DEBUG} ]] && \
	debug "${FUNCNAME} (${LINENO}): Number of audio interfaces after filtering: \
 ${#ALSA_AIF_HWADDRESSES[@]}"

    if [[ ! -z ${PROFILE} ]]; then
	## end profiling
	set +x
	exec 2>&3 3>&-
	debug "${FUNCNAME} (${LINENO}): Profiling information stored in: ${profile_file}"
    fi

    ## return success if interfaces are found
    return 0
}

### global variables

## indexed arrays to store the details of interfaces of one would
## declare such an array in another script, that array would be filled
## instead of these. See examples/bash-example.sh for usage.
set +u

[[ -z ${ALSA_AIF_HWADDRESSES} ]] && declare -a ALSA_AIF_HWADDRESSES=()
[[ -z ${ALSA_AIF_DISPLAYTITLES} ]] && declare -a ALSA_AIF_DISPLAYTITLES=()
[[ -z ${ALSA_AIF_MONITORFILES} ]] && declare -a ALSA_AIF_MONITORFILES=()
[[ -z ${ALSA_AIF_DEVLABELS} ]] && declare -a ALSA_AIF_DEVLABELS=()
[[ -z ${ALSA_AIF_LABELS} ]] && declare -a ALSA_AIF_LABELS=()
[[ -z ${ALSA_AIF_UACCLASSES} ]] && declare -a ALSA_AIF_UACCLASSES=()
[[ -z ${ALSA_AIF_FORMATS} ]] && declare -a ALSA_AIF_FORMATS=()
[[ -z ${ALSA_AIF_CHARDEVS} ]] && declare -a ALSA_AIF_CHARDEVS=()

set -u

## counter for unfiltered interfaces
NR_AIFS_BEFOREFILTERING=0

## static filter for digital interfaces
DO_FILTER_LIST="$(cat <<EOF
adat
aes
ebu
digital
dsd
hdmi
i2s
iec958
spdif
s/pdif
toslink
uac
usb
EOF
    )"

## construct static list of sample rates
## based on ground clock frequencies of
##  - video standard: 24.576  (mHz) * 1000000 / 512 = 48000Hz
##  - audio standard: 22.5792 (mHz) * 1000000 / 512 = 44100Hz

base_fs_video=$(( 24576000 / 512 ))
base_fs_audio=$(( 22579200 / 512 ))
## initialize audio rates with fs*1 (cd)
declare -a SAMPLERATES_AUDIO=(${base_fs_audio})
## initalize video rates with base * 2/3 (which seems common)
declare -a SAMPLERATES_VIDEO=($(( base_fs_video * 2 / 3 )) ${base_fs_video})

## max multiplier: fs*n
max_fs_n=8
rate=0
n=2;
while [[ ${n} -le ${max_fs_n} ]]; do
    rate=$(( base_fs_video * n ))
    SAMPLERATES_VIDEO+=(${rate})
    n=$(( n * 2 ))
done
n=2;
while [[ ${n} -le ${max_fs_n} ]]; do
    rate=$(( base_fs_audio * n ))
    SAMPLERATES_AUDIO+=(${rate})
    n=$(( n * 2 ))
done

## pseudo random data to generate noise
PSEUDO_RANDOM_NOISE="30985218341569576428057261168568123489906994"
declare -a DO_INTERFACE_FILTER=($(printf -- '%s' "${DO_FILTER_LIST// /" "}"))

## construction for displayed output
UAC="USB Audio Class"
ALSA_IF_LABEL="alsa audio output interface"
declare -A ALSA_IF_LABELS=()
ALSA_IF_LABELS+=(["ao"]="Analog ${ALSA_IF_LABEL}")
ALSA_IF_LABELS+=(["do"]="Digital ${ALSA_IF_LABEL}")
ALSA_IF_LABELS+=(["uo"]="${UAC} ${ALSA_IF_LABELS[do]}")
ALSA_NON_DO_IF="${ALSA_IF_LABELS[ao]}"
ALSA_NON_UO_IF="Non-UAC ${ALSA_IF_LABELS[do]}"

## USB_SYNC_TYPEs
## strings alsa uses for UAC endpoint descriptors.
## one of *sync_types "NONE", "ASYNC", "ADAPTIVE" or "SYNC" according
## to ./sound/usb/proc.c
UO_EP_NONE_FILTER="NONE"
UO_EP_ADAPT_FILTER="ADAPTIVE"
UO_EP_ASYNC_FILTER="ASYNC"
UO_EP_SYNC_FILTER="SYNC"
## labels for UAC classes.
UO_EP_NONE_LABEL="0 - (none)"
UO_EP_ADAPT_LABEL="1 - isochronous adaptive"
UO_EP_ASYNC_LABEL="2 - isochronous asynchronous"
UO_EP_SYNC_LABEL="3 - sync (?)"
## declarative array holding the available UAC classes with
## description
declare -A UO_EP_LABELS=( ["${UO_EP_NONE_FILTER}"]="${UO_EP_NONE_LABEL}"
			  ["${UO_EP_ADAPT_FILTER}"]="${UO_EP_ADAPT_LABEL}"
			  ["${UO_EP_ASYNC_FILTER}"]="${UO_EP_ASYNC_LABEL}"
			  ["${UO_EP_SYNC_FILTER}"]="${UO_EP_SYNC_LABEL}" )

## system messages
MSG_PROP_NOTAPPLICABLE="(n/a)"
MSG_PROP_NOTAVAILABLE="(none)"
MSG_ERROR_GETTINGFORMATS="can't detect formats or rates because device is locked"
MSG_ERROR_NOFILE="is not a file or is not accessible."
MSG_ERROR_UNEXPECTED="THIS SHOULD NOT HAPPEN."
MSG_APLAY_ERROR_NOSOUNDCARDS="aplay did not find any soundcard."
MSG_APLAY_ERROR_GENERAL="aplay reported the following error:\n\`%s'"
MSG_APLAY_ERROR_UNSPECIFIED="aplay returned no results."
MSG_APLAY_USINGTESTFILE="NOTICE: using fake aplay output stored in TESTFILE: \`%s'."
MSG_APLAY_ERROR_NOSUCHTESTFILE="Specified TESTFILE \'%s' does not exist."
MSG_APLAY_ERROR_OPENINGTESTFILE="Error opening TESTFILE \'%s'."
MSG_NO_DEVICE="no such device"
MSG_NO_FILE="no such file"
MSG_TAB=" * "
MSG_MARGIN="${MSG_TAB//\*/ }"
MSG_MATCH_IF_NONE_UNLIMITED="${MSG_TAB}No ${ALSA_IF_LABEL}s found."
MSG_MATCH_IF_NONE_LIMITED="${MSG_TAB}From the %s available ${ALSA_IF_LABEL}s, \
none matched your filter."
MSG_ERROR_DETERMINE_FORMATS="error: can't determine"
MSG_ERROR_CHARDEV_NOFORMATS="can't determine: character device error"
MSG_ERROR_NOT_CHARDEV="error: is not a character device or not accessible"
## construct a list with the properties of the current
## interface if `OPT_QUIET' is not set
MSG_ALSA_DEVNAME="device name"
MSG_ALSA_CODECNAME="codec name"
MSG_ALSA_IFNAME="interface name"
MSG_ALSA_UACCLASS="usb audio class"
MSG_ALSA_CHARDEV="character device"
MSG_ALSA_ENCODINGFORMATS="encoding formats"
MSG_ALSA_PACKINGFORMATS="packing formats"
MSG_ALSA_SAMPLERATES="sample rates"
MSG_ALSA_MONITORFILE="monitor file"

## command line options
## input parameters for the limit option
## should be consequtive pairs of '"x" "long option"'
declare -a OPT_LIMIT_ARGS=("a" "analog" "d" "digital" "u" "usb")
## also see analyze_command_line
OPT_LIMIT_AO=${OPT_LIMIT_AO:-}
OPT_LIMIT_DO=${OPT_LIMIT_DO:-}
OPT_LIMIT_UO=${OPT_LIMIT_UO:-}
OPT_QUIET=${OPT_QUIET:-}
OPT_FILTER=${OPT_FILTER:-}
OPT_HWFILTER=${OPT_HWFILTER:-}
OPT_SAMPLERATES=${OPT_SAMPLERATES:-}

## currently unused
PA_HELPER_SCRIPT="pulseaudio-helper"

## if the script is not sourced by another script but run within its
## own shell call function `return_alsa_interface'
[[ "${BASH_SOURCE[0]:-}" != "${0}" ]] || return_alsa_interface "$@"

